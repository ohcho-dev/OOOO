"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-lottie-player";
exports.ids = ["vendor-chunks/react-lottie-player"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-lottie-player/dist/LottiePlayer.modern.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-lottie-player/dist/LottiePlayer.modern.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var lottie_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lottie-web */ \"(ssr)/./node_modules/lottie-web/build/player/lottie.js\");\n/* harmony import */ var lottie_web__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lottie_web__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var fast_deep_equal_es6_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-deep-equal/es6/react */ \"(ssr)/./node_modules/fast-deep-equal/es6/react.js\");\n/* harmony import */ var fast_deep_equal_es6_react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal_es6_react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var rfdc_default__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rfdc/default */ \"(ssr)/./node_modules/rfdc/default.js\");\n/* harmony import */ var rfdc_default__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(rfdc_default__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction createCommonjsModule(fn, module) {\n    return module = {\n        exports: {}\n    }, fn(module, module.exports), module.exports;\n}\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var b = \"function\" === typeof Symbol && Symbol.for, c = b ? Symbol.for(\"react.element\") : 60103, d = b ? Symbol.for(\"react.portal\") : 60106, e = b ? Symbol.for(\"react.fragment\") : 60107, f = b ? Symbol.for(\"react.strict_mode\") : 60108, g = b ? Symbol.for(\"react.profiler\") : 60114, h = b ? Symbol.for(\"react.provider\") : 60109, k = b ? Symbol.for(\"react.context\") : 60110, l = b ? Symbol.for(\"react.async_mode\") : 60111, m = b ? Symbol.for(\"react.concurrent_mode\") : 60111, n = b ? Symbol.for(\"react.forward_ref\") : 60112, p = b ? Symbol.for(\"react.suspense\") : 60113, q = b ? Symbol.for(\"react.suspense_list\") : 60120, r = b ? Symbol.for(\"react.memo\") : 60115, t = b ? Symbol.for(\"react.lazy\") : 60116, v = b ? Symbol.for(\"react.block\") : 60121, w = b ? Symbol.for(\"react.fundamental\") : 60117, x = b ? Symbol.for(\"react.responder\") : 60118, y = b ? Symbol.for(\"react.scope\") : 60119;\nfunction z(a) {\n    if (\"object\" === typeof a && null !== a) {\n        var u = a.$$typeof;\n        switch(u){\n            case c:\n                switch(a = a.type, a){\n                    case l:\n                    case m:\n                    case e:\n                    case g:\n                    case f:\n                    case p:\n                        return a;\n                    default:\n                        switch(a = a && a.$$typeof, a){\n                            case k:\n                            case n:\n                            case t:\n                            case r:\n                            case h:\n                                return a;\n                            default:\n                                return u;\n                        }\n                }\n            case d:\n                return u;\n        }\n    }\n}\nfunction A(a) {\n    return z(a) === m;\n}\nvar AsyncMode = l;\nvar ConcurrentMode = m;\nvar ContextConsumer = k;\nvar ContextProvider = h;\nvar Element = c;\nvar ForwardRef = n;\nvar Fragment = e;\nvar Lazy = t;\nvar Memo = r;\nvar Portal = d;\nvar Profiler = g;\nvar StrictMode = f;\nvar Suspense = p;\nvar isAsyncMode = function(a) {\n    return A(a) || z(a) === l;\n};\nvar isConcurrentMode = A;\nvar isContextConsumer = function(a) {\n    return z(a) === k;\n};\nvar isContextProvider = function(a) {\n    return z(a) === h;\n};\nvar isElement = function(a) {\n    return \"object\" === typeof a && null !== a && a.$$typeof === c;\n};\nvar isForwardRef = function(a) {\n    return z(a) === n;\n};\nvar isFragment = function(a) {\n    return z(a) === e;\n};\nvar isLazy = function(a) {\n    return z(a) === t;\n};\nvar isMemo = function(a) {\n    return z(a) === r;\n};\nvar isPortal = function(a) {\n    return z(a) === d;\n};\nvar isProfiler = function(a) {\n    return z(a) === g;\n};\nvar isStrictMode = function(a) {\n    return z(a) === f;\n};\nvar isSuspense = function(a) {\n    return z(a) === p;\n};\nvar isValidElementType = function(a) {\n    return \"string\" === typeof a || \"function\" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || \"object\" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);\n};\nvar typeOf = z;\nvar reactIs_production_min = {\n    AsyncMode: AsyncMode,\n    ConcurrentMode: ConcurrentMode,\n    ContextConsumer: ContextConsumer,\n    ContextProvider: ContextProvider,\n    Element: Element,\n    ForwardRef: ForwardRef,\n    Fragment: Fragment,\n    Lazy: Lazy,\n    Memo: Memo,\n    Portal: Portal,\n    Profiler: Profiler,\n    StrictMode: StrictMode,\n    Suspense: Suspense,\n    isAsyncMode: isAsyncMode,\n    isConcurrentMode: isConcurrentMode,\n    isContextConsumer: isContextConsumer,\n    isContextProvider: isContextProvider,\n    isElement: isElement,\n    isForwardRef: isForwardRef,\n    isFragment: isFragment,\n    isLazy: isLazy,\n    isMemo: isMemo,\n    isPortal: isPortal,\n    isProfiler: isProfiler,\n    isStrictMode: isStrictMode,\n    isSuspense: isSuspense,\n    isValidElementType: isValidElementType,\n    typeOf: typeOf\n};\nvar reactIs_development = createCommonjsModule(function(module, exports) {\n    if (true) {\n        (function() {\n            // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n            // nor polyfill, then a plain number is used for performance.\n            var hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n            var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 0xeac7;\n            var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 0xeaca;\n            var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 0xeacb;\n            var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.strict_mode\") : 0xeacc;\n            var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 0xead2;\n            var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 0xeacd;\n            var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n            // (unstable) APIs that have been removed. Can we remove the symbols?\n            var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 0xeacf;\n            var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.concurrent_mode\") : 0xeacf;\n            var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\"react.forward_ref\") : 0xead0;\n            var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\"react.suspense\") : 0xead1;\n            var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for(\"react.suspense_list\") : 0xead8;\n            var REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\"react.memo\") : 0xead3;\n            var REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\"react.lazy\") : 0xead4;\n            var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for(\"react.block\") : 0xead9;\n            var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for(\"react.fundamental\") : 0xead5;\n            var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for(\"react.responder\") : 0xead6;\n            var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for(\"react.scope\") : 0xead7;\n            function isValidElementType(type) {\n                return typeof type === \"string\" || typeof type === \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n                type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n            }\n            function typeOf(object) {\n                if (typeof object === \"object\" && object !== null) {\n                    var $$typeof = object.$$typeof;\n                    switch($$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            var type = object.type;\n                            switch(type){\n                                case REACT_ASYNC_MODE_TYPE:\n                                case REACT_CONCURRENT_MODE_TYPE:\n                                case REACT_FRAGMENT_TYPE:\n                                case REACT_PROFILER_TYPE:\n                                case REACT_STRICT_MODE_TYPE:\n                                case REACT_SUSPENSE_TYPE:\n                                    return type;\n                                default:\n                                    var $$typeofType = type && type.$$typeof;\n                                    switch($$typeofType){\n                                        case REACT_CONTEXT_TYPE:\n                                        case REACT_FORWARD_REF_TYPE:\n                                        case REACT_LAZY_TYPE:\n                                        case REACT_MEMO_TYPE:\n                                        case REACT_PROVIDER_TYPE:\n                                            return $$typeofType;\n                                        default:\n                                            return $$typeof;\n                                    }\n                            }\n                        case REACT_PORTAL_TYPE:\n                            return $$typeof;\n                    }\n                }\n                return undefined;\n            } // AsyncMode is deprecated along with isAsyncMode\n            var AsyncMode = REACT_ASYNC_MODE_TYPE;\n            var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n            var ContextConsumer = REACT_CONTEXT_TYPE;\n            var ContextProvider = REACT_PROVIDER_TYPE;\n            var Element = REACT_ELEMENT_TYPE;\n            var ForwardRef = REACT_FORWARD_REF_TYPE;\n            var Fragment = REACT_FRAGMENT_TYPE;\n            var Lazy = REACT_LAZY_TYPE;\n            var Memo = REACT_MEMO_TYPE;\n            var Portal = REACT_PORTAL_TYPE;\n            var Profiler = REACT_PROFILER_TYPE;\n            var StrictMode = REACT_STRICT_MODE_TYPE;\n            var Suspense = REACT_SUSPENSE_TYPE;\n            var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n            function isAsyncMode(object) {\n                {\n                    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n                        hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n                        console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, \" + \"and will be removed in React 17+. Update your code to use \" + \"ReactIs.isConcurrentMode() instead. It has the exact same API.\");\n                    }\n                }\n                return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n            }\n            function isConcurrentMode(object) {\n                return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n            }\n            function isContextConsumer(object) {\n                return typeOf(object) === REACT_CONTEXT_TYPE;\n            }\n            function isContextProvider(object) {\n                return typeOf(object) === REACT_PROVIDER_TYPE;\n            }\n            function isElement(object) {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n            function isForwardRef(object) {\n                return typeOf(object) === REACT_FORWARD_REF_TYPE;\n            }\n            function isFragment(object) {\n                return typeOf(object) === REACT_FRAGMENT_TYPE;\n            }\n            function isLazy(object) {\n                return typeOf(object) === REACT_LAZY_TYPE;\n            }\n            function isMemo(object) {\n                return typeOf(object) === REACT_MEMO_TYPE;\n            }\n            function isPortal(object) {\n                return typeOf(object) === REACT_PORTAL_TYPE;\n            }\n            function isProfiler(object) {\n                return typeOf(object) === REACT_PROFILER_TYPE;\n            }\n            function isStrictMode(object) {\n                return typeOf(object) === REACT_STRICT_MODE_TYPE;\n            }\n            function isSuspense(object) {\n                return typeOf(object) === REACT_SUSPENSE_TYPE;\n            }\n            exports.AsyncMode = AsyncMode;\n            exports.ConcurrentMode = ConcurrentMode;\n            exports.ContextConsumer = ContextConsumer;\n            exports.ContextProvider = ContextProvider;\n            exports.Element = Element;\n            exports.ForwardRef = ForwardRef;\n            exports.Fragment = Fragment;\n            exports.Lazy = Lazy;\n            exports.Memo = Memo;\n            exports.Portal = Portal;\n            exports.Profiler = Profiler;\n            exports.StrictMode = StrictMode;\n            exports.Suspense = Suspense;\n            exports.isAsyncMode = isAsyncMode;\n            exports.isConcurrentMode = isConcurrentMode;\n            exports.isContextConsumer = isContextConsumer;\n            exports.isContextProvider = isContextProvider;\n            exports.isElement = isElement;\n            exports.isForwardRef = isForwardRef;\n            exports.isFragment = isFragment;\n            exports.isLazy = isLazy;\n            exports.isMemo = isMemo;\n            exports.isPortal = isPortal;\n            exports.isProfiler = isProfiler;\n            exports.isStrictMode = isStrictMode;\n            exports.isSuspense = isSuspense;\n            exports.isValidElementType = isValidElementType;\n            exports.typeOf = typeOf;\n        })();\n    }\n});\nvar reactIs = createCommonjsModule(function(module) {\n    if (false) {} else {\n        module.exports = reactIs_development;\n    }\n});\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/ /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\nfunction toObject(val) {\n    if (val === null || val === undefined) {\n        throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n    }\n    return Object(val);\n}\nfunction shouldUseNative() {\n    try {\n        if (!Object.assign) {\n            return false;\n        }\n        // Detect buggy property enumeration order in older V8 versions.\n        // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n        var test1 = new String(\"abc\"); // eslint-disable-line no-new-wrappers\n        test1[5] = \"de\";\n        if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n            return false;\n        }\n        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n        var test2 = {};\n        for(var i = 0; i < 10; i++){\n            test2[\"_\" + String.fromCharCode(i)] = i;\n        }\n        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n            return test2[n];\n        });\n        if (order2.join(\"\") !== \"0123456789\") {\n            return false;\n        }\n        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n        var test3 = {};\n        \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n            test3[letter] = letter;\n        });\n        if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n            return false;\n        }\n        return true;\n    } catch (err) {\n        // We don't expect any of the above to throw, but better to be safe.\n        return false;\n    }\n}\nvar objectAssign = shouldUseNative() ? Object.assign : function(target, source) {\n    var from;\n    var to = toObject(target);\n    var symbols;\n    for(var s = 1; s < arguments.length; s++){\n        from = Object(arguments[s]);\n        for(var key in from){\n            if (hasOwnProperty.call(from, key)) {\n                to[key] = from[key];\n            }\n        }\n        if (getOwnPropertySymbols) {\n            symbols = getOwnPropertySymbols(from);\n            for(var i = 0; i < symbols.length; i++){\n                if (propIsEnumerable.call(from, symbols[i])) {\n                    to[symbols[i]] = from[symbols[i]];\n                }\n            }\n        }\n    }\n    return to;\n};\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\nvar ReactPropTypesSecret_1 = ReactPropTypesSecret;\nvar has = Function.call.bind(Object.prototype.hasOwnProperty);\nvar printWarning = function() {};\nif (true) {\n    var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;\n    var loggedTypeFailures = {};\n    var has$1 = has;\n    printWarning = function(text) {\n        var message = \"Warning: \" + text;\n        if (typeof console !== \"undefined\") {\n            console.error(message);\n        }\n        try {\n            // --- Welcome to debugging React ---\n            // This error was thrown as a convenience so that you can use this stack\n            // to find the callsite that caused this warning to fire.\n            throw new Error(message);\n        } catch (x) {}\n    };\n}\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n    if (true) {\n        for(var typeSpecName in typeSpecs){\n            if (has$1(typeSpecs, typeSpecName)) {\n                var error;\n                // Prop type validation may throw. In case they do, we don't want to\n                // fail the render phase where it didn't fail before. So we log it.\n                // After these have been cleaned up, we'll let them throw.\n                try {\n                    // This is intentionally an invariant that gets caught. It's the same\n                    // behavior as without this statement except with a better message.\n                    if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                        var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                        err.name = \"Invariant Violation\";\n                        throw err;\n                    }\n                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);\n                } catch (ex) {\n                    error = ex;\n                }\n                if (error && !(error instanceof Error)) {\n                    printWarning((componentName || \"React class\") + \": type specification of \" + location + \" `\" + typeSpecName + \"` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a \" + typeof error + \". \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\");\n                }\n                if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                    // Only monitor this failure once because there tends to be a lot of the\n                    // same error.\n                    loggedTypeFailures[error.message] = true;\n                    var stack = getStack ? getStack() : \"\";\n                    printWarning(\"Failed \" + location + \" type: \" + error.message + (stack != null ? stack : \"\"));\n                }\n            }\n        }\n    }\n}\n/**\n * Resets warning cache when testing.\n *\n * @private\n */ checkPropTypes.resetWarningCache = function() {\n    if (true) {\n        loggedTypeFailures = {};\n    }\n};\nvar checkPropTypes_1 = checkPropTypes;\nvar printWarning$1 = function() {};\nif (true) {\n    printWarning$1 = function(text) {\n        var message = \"Warning: \" + text;\n        if (typeof console !== \"undefined\") {\n            console.error(message);\n        }\n        try {\n            // --- Welcome to debugging React ---\n            // This error was thrown as a convenience so that you can use this stack\n            // to find the callsite that caused this warning to fire.\n            throw new Error(message);\n        } catch (x) {}\n    };\n}\nfunction emptyFunctionThatReturnsNull() {\n    return null;\n}\nvar factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {\n    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = \"@@iterator\"; // Before Symbol spec.\n    /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */ function getIteratorFn(maybeIterable) {\n        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n        if (typeof iteratorFn === \"function\") {\n            return iteratorFn;\n        }\n    }\n    /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */ var ANONYMOUS = \"<<anonymous>>\";\n    // Important!\n    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n    var ReactPropTypes = {\n        array: createPrimitiveTypeChecker(\"array\"),\n        bigint: createPrimitiveTypeChecker(\"bigint\"),\n        bool: createPrimitiveTypeChecker(\"boolean\"),\n        func: createPrimitiveTypeChecker(\"function\"),\n        number: createPrimitiveTypeChecker(\"number\"),\n        object: createPrimitiveTypeChecker(\"object\"),\n        string: createPrimitiveTypeChecker(\"string\"),\n        symbol: createPrimitiveTypeChecker(\"symbol\"),\n        any: createAnyTypeChecker(),\n        arrayOf: createArrayOfTypeChecker,\n        element: createElementTypeChecker(),\n        elementType: createElementTypeTypeChecker(),\n        instanceOf: createInstanceTypeChecker,\n        node: createNodeChecker(),\n        objectOf: createObjectOfTypeChecker,\n        oneOf: createEnumTypeChecker,\n        oneOfType: createUnionTypeChecker,\n        shape: createShapeTypeChecker,\n        exact: createStrictShapeTypeChecker\n    };\n    /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */ /*eslint-disable no-self-compare*/ function is(x, y) {\n        // SameValue algorithm\n        if (x === y) {\n            // Steps 1-5, 7-10\n            // Steps 6.b-6.e: +0 != -0\n            return x !== 0 || 1 / x === 1 / y;\n        } else {\n            // Step 6.a: NaN == NaN\n            return x !== x && y !== y;\n        }\n    }\n    /*eslint-enable no-self-compare*/ /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */ function PropTypeError(message, data) {\n        this.message = message;\n        this.data = data && typeof data === \"object\" ? data : {};\n        this.stack = \"\";\n    }\n    // Make `instanceof Error` still work for returned errors.\n    PropTypeError.prototype = Error.prototype;\n    function createChainableTypeChecker(validate) {\n        if (true) {\n            var manualPropTypeCallCache = {};\n            var manualPropTypeWarningCount = 0;\n        }\n        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n            componentName = componentName || ANONYMOUS;\n            propFullName = propFullName || propName;\n            if (secret !== ReactPropTypesSecret_1) {\n                if (throwOnDirectAccess) {\n                    // New behavior only for users of `prop-types` package\n                    var err = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use `PropTypes.checkPropTypes()` to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                    err.name = \"Invariant Violation\";\n                    throw err;\n                } else if ( true && typeof console !== \"undefined\") {\n                    // Old behavior for people using React.PropTypes\n                    var cacheKey = componentName + \":\" + propName;\n                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n                    manualPropTypeWarningCount < 3) {\n                        printWarning$1(\"You are manually calling a React.PropTypes validation \" + \"function for the `\" + propFullName + \"` prop on `\" + componentName + \"`. This is deprecated \" + \"and will throw in the standalone `prop-types` package. \" + \"You may be seeing this warning due to a third-party PropTypes \" + \"library. See https://fb.me/react-warning-dont-call-proptypes \" + \"for details.\");\n                        manualPropTypeCallCache[cacheKey] = true;\n                        manualPropTypeWarningCount++;\n                    }\n                }\n            }\n            if (props[propName] == null) {\n                if (isRequired) {\n                    if (props[propName] === null) {\n                        return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n                    }\n                    return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n                }\n                return null;\n            } else {\n                return validate(props, propName, componentName, location, propFullName);\n            }\n        }\n        var chainedCheckType = checkType.bind(null, false);\n        chainedCheckType.isRequired = checkType.bind(null, true);\n        return chainedCheckType;\n    }\n    function createPrimitiveTypeChecker(expectedType) {\n        function validate(props, propName, componentName, location, propFullName, secret) {\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== expectedType) {\n                // `propValue` being instance of, say, date/regexp, pass the 'object'\n                // check, but we can offer a more precise error message here rather than\n                // 'of type `object`'.\n                var preciseType = getPreciseType(propValue);\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"), {\n                    expectedType: expectedType\n                });\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createAnyTypeChecker() {\n        return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n    }\n    function createArrayOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (typeof typeChecker !== \"function\") {\n                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n            }\n            var propValue = props[propName];\n            if (!Array.isArray(propValue)) {\n                var propType = getPropType(propValue);\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n            }\n            for(var i = 0; i < propValue.length; i++){\n                var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret_1);\n                if (error instanceof Error) {\n                    return error;\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createElementTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            if (!isValidElement(propValue)) {\n                var propType = getPropType(propValue);\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createElementTypeTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            if (!reactIs.isValidElementType(propValue)) {\n                var propType = getPropType(propValue);\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement type.\"));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createInstanceTypeChecker(expectedClass) {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (!(props[propName] instanceof expectedClass)) {\n                var expectedClassName = expectedClass.name || ANONYMOUS;\n                var actualClassName = getClassName(props[propName]);\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createEnumTypeChecker(expectedValues) {\n        if (!Array.isArray(expectedValues)) {\n            if (true) {\n                if (arguments.length > 1) {\n                    printWarning$1(\"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. \" + \"A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\");\n                } else {\n                    printWarning$1(\"Invalid argument supplied to oneOf, expected an array.\");\n                }\n            }\n            return emptyFunctionThatReturnsNull;\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            for(var i = 0; i < expectedValues.length; i++){\n                if (is(propValue, expectedValues[i])) {\n                    return null;\n                }\n            }\n            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n                var type = getPreciseType(value);\n                if (type === \"symbol\") {\n                    return String(value);\n                }\n                return value;\n            });\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + String(propValue) + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createObjectOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (typeof typeChecker !== \"function\") {\n                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n            }\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== \"object\") {\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n            }\n            for(var key in propValue){\n                if (has(propValue, key)) {\n                    var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret_1);\n                    if (error instanceof Error) {\n                        return error;\n                    }\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createUnionTypeChecker(arrayOfTypeCheckers) {\n        if (!Array.isArray(arrayOfTypeCheckers)) {\n             true ? printWarning$1(\"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n            return emptyFunctionThatReturnsNull;\n        }\n        for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n            var checker = arrayOfTypeCheckers[i];\n            if (typeof checker !== \"function\") {\n                printWarning$1(\"Invalid argument supplied to oneOfType. Expected an array of check functions, but \" + \"received \" + getPostfixForTypeWarning(checker) + \" at index \" + i + \".\");\n                return emptyFunctionThatReturnsNull;\n            }\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n            var expectedTypes = [];\n            for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                var checker = arrayOfTypeCheckers[i];\n                var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1);\n                if (checkerResult == null) {\n                    return null;\n                }\n                if (checkerResult.data && has(checkerResult.data, \"expectedType\")) {\n                    expectedTypes.push(checkerResult.data.expectedType);\n                }\n            }\n            var expectedTypesMessage = expectedTypes.length > 0 ? \", expected one of type [\" + expectedTypes.join(\", \") + \"]\" : \"\";\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`\" + expectedTypesMessage + \".\"));\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createNodeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (!isNode(props[propName])) {\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function invalidValidatorError(componentName, location, propFullName, key, type) {\n        return new PropTypeError((componentName || \"React class\") + \": \" + location + \" type `\" + propFullName + \".\" + key + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + type + \"`.\");\n    }\n    function createShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== \"object\") {\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n            }\n            for(var key in shapeTypes){\n                var checker = shapeTypes[key];\n                if (typeof checker !== \"function\") {\n                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n                }\n                var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret_1);\n                if (error) {\n                    return error;\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createStrictShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== \"object\") {\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n            }\n            // We need to check all keys in case some are required but missing from props.\n            var allKeys = objectAssign({}, props[propName], shapeTypes);\n            for(var key in allKeys){\n                var checker = shapeTypes[key];\n                if (has(shapeTypes, key) && typeof checker !== \"function\") {\n                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n                }\n                if (!checker) {\n                    return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\" + \"\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n                }\n                var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret_1);\n                if (error) {\n                    return error;\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function isNode(propValue) {\n        switch(typeof propValue){\n            case \"number\":\n            case \"string\":\n            case \"undefined\":\n                return true;\n            case \"boolean\":\n                return !propValue;\n            case \"object\":\n                if (Array.isArray(propValue)) {\n                    return propValue.every(isNode);\n                }\n                if (propValue === null || isValidElement(propValue)) {\n                    return true;\n                }\n                var iteratorFn = getIteratorFn(propValue);\n                if (iteratorFn) {\n                    var iterator = iteratorFn.call(propValue);\n                    var step;\n                    if (iteratorFn !== propValue.entries) {\n                        while(!(step = iterator.next()).done){\n                            if (!isNode(step.value)) {\n                                return false;\n                            }\n                        }\n                    } else {\n                        // Iterator will provide entry [k,v] tuples rather than values.\n                        while(!(step = iterator.next()).done){\n                            var entry = step.value;\n                            if (entry) {\n                                if (!isNode(entry[1])) {\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    return false;\n                }\n                return true;\n            default:\n                return false;\n        }\n    }\n    function isSymbol(propType, propValue) {\n        // Native Symbol.\n        if (propType === \"symbol\") {\n            return true;\n        }\n        // falsy value can't be a Symbol\n        if (!propValue) {\n            return false;\n        }\n        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n        if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n            return true;\n        }\n        // Fallback for non-spec compliant Symbols which are polyfilled.\n        if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n            return true;\n        }\n        return false;\n    }\n    // Equivalent of `typeof` but with special handling for array and regexp.\n    function getPropType(propValue) {\n        var propType = typeof propValue;\n        if (Array.isArray(propValue)) {\n            return \"array\";\n        }\n        if (propValue instanceof RegExp) {\n            // Old webkits (at least until Android 4.0) return 'function' rather than\n            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n            // passes PropTypes.object.\n            return \"object\";\n        }\n        if (isSymbol(propType, propValue)) {\n            return \"symbol\";\n        }\n        return propType;\n    }\n    // This handles more types than `getPropType`. Only used for error messages.\n    // See `createPrimitiveTypeChecker`.\n    function getPreciseType(propValue) {\n        if (typeof propValue === \"undefined\" || propValue === null) {\n            return \"\" + propValue;\n        }\n        var propType = getPropType(propValue);\n        if (propType === \"object\") {\n            if (propValue instanceof Date) {\n                return \"date\";\n            } else if (propValue instanceof RegExp) {\n                return \"regexp\";\n            }\n        }\n        return propType;\n    }\n    // Returns a string that is postfixed to a warning about an invalid type.\n    // For example, \"undefined\" or \"of type array\"\n    function getPostfixForTypeWarning(value) {\n        var type = getPreciseType(value);\n        switch(type){\n            case \"array\":\n            case \"object\":\n                return \"an \" + type;\n            case \"boolean\":\n            case \"date\":\n            case \"regexp\":\n                return \"a \" + type;\n            default:\n                return type;\n        }\n    }\n    // Returns class name of the object, if any.\n    function getClassName(propValue) {\n        if (!propValue.constructor || !propValue.constructor.name) {\n            return ANONYMOUS;\n        }\n        return propValue.constructor.name;\n    }\n    ReactPropTypes.checkPropTypes = checkPropTypes_1;\n    ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;\n    ReactPropTypes.PropTypes = ReactPropTypes;\n    return ReactPropTypes;\n};\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\nvar factoryWithThrowingShims = function() {\n    function shim(props, propName, componentName, location, propFullName, secret) {\n        if (secret === ReactPropTypesSecret_1) {\n            // It is still safe when called from React.\n            return;\n        }\n        var err = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use PropTypes.checkPropTypes() to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n        err.name = \"Invariant Violation\";\n        throw err;\n    }\n    shim.isRequired = shim;\n    function getShim() {\n        return shim;\n    } // Important!\n    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n    var ReactPropTypes = {\n        array: shim,\n        bigint: shim,\n        bool: shim,\n        func: shim,\n        number: shim,\n        object: shim,\n        string: shim,\n        symbol: shim,\n        any: shim,\n        arrayOf: getShim,\n        element: shim,\n        elementType: shim,\n        instanceOf: getShim,\n        node: shim,\n        objectOf: getShim,\n        oneOf: getShim,\n        oneOfType: getShim,\n        shape: getShim,\n        exact: getShim,\n        checkPropTypes: emptyFunctionWithReset,\n        resetWarningCache: emptyFunction\n    };\n    ReactPropTypes.PropTypes = ReactPropTypes;\n    return ReactPropTypes;\n};\nvar propTypes = createCommonjsModule(function(module) {\n    /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n        var ReactIs = reactIs;\n        // By explicitly using `prop-types` you are opting into new development behavior.\n        // http://fb.me/prop-types-in-prod\n        var throwOnDirectAccess = true;\n        module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);\n    } else {}\n});\nvar propTypes$1 = {\n    animationData: propTypes.object,\n    path: propTypes.string,\n    play: propTypes.bool,\n    goTo: propTypes.number,\n    speed: propTypes.number,\n    direction: propTypes.number,\n    loop: propTypes.oneOfType([\n        propTypes.number,\n        propTypes.bool\n    ]),\n    useSubframes: propTypes.bool,\n    segments: propTypes.oneOfType([\n        propTypes.arrayOf(propTypes.number),\n        propTypes.bool\n    ]),\n    rendererSettings: propTypes.object,\n    renderer: propTypes.string,\n    audioFactory: propTypes.func,\n    onComplete: propTypes.func,\n    onLoopComplete: propTypes.func,\n    onEnterFrame: propTypes.func,\n    onSegmentStart: propTypes.func\n};\nvar emptyObject = {};\nvar noOp = function noOp() {};\nvar makeLottiePlayer = function makeLottiePlayer(_ref) {\n    var loadAnimation = _ref.loadAnimation;\n    var Lottie = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function(params, forwardedRef) {\n        var _params$animationData = params.animationData, animationData = _params$animationData === void 0 ? null : _params$animationData, _params$path = params.path, path = _params$path === void 0 ? null : _params$path, _params$play = params.play, play = _params$play === void 0 ? null : _params$play, _params$speed = params.speed, speed = _params$speed === void 0 ? 1 : _params$speed, _params$direction = params.direction, direction = _params$direction === void 0 ? 1 : _params$direction, _params$segments = params.segments, segmentsIn = _params$segments === void 0 ? null : _params$segments, _params$goTo = params.goTo, goTo = _params$goTo === void 0 ? null : _params$goTo, _params$useSubframes = params.useSubframes, useSubframes = _params$useSubframes === void 0 ? true : _params$useSubframes, _params$renderer = params.renderer, renderer = _params$renderer === void 0 ? \"svg\" : _params$renderer, _params$loop = params.loop, loop = _params$loop === void 0 ? true : _params$loop, _params$rendererSetti = params.rendererSettings, rendererSettingsIn = _params$rendererSetti === void 0 ? emptyObject : _params$rendererSetti, _params$audioFactory = params.audioFactory, audioFactory = _params$audioFactory === void 0 ? null : _params$audioFactory, _params$onLoad = params.onLoad, onLoad = _params$onLoad === void 0 ? noOp : _params$onLoad, _params$onComplete = params.onComplete, onComplete = _params$onComplete === void 0 ? noOp : _params$onComplete, _params$onLoopComplet = params.onLoopComplete, onLoopComplete = _params$onLoopComplet === void 0 ? noOp : _params$onLoopComplet, _params$onEnterFrame = params.onEnterFrame, onEnterFrame = _params$onEnterFrame === void 0 ? noOp : _params$onEnterFrame, _params$onSegmentStar = params.onSegmentStart, onSegmentStart = _params$onSegmentStar === void 0 ? noOp : _params$onSegmentStar, props = _objectWithoutPropertiesLoose(params, [\n            \"animationData\",\n            \"path\",\n            \"play\",\n            \"speed\",\n            \"direction\",\n            \"segments\",\n            \"goTo\",\n            \"useSubframes\",\n            \"renderer\",\n            \"loop\",\n            \"rendererSettings\",\n            \"audioFactory\",\n            \"onLoad\",\n            \"onComplete\",\n            \"onLoopComplete\",\n            \"onEnterFrame\",\n            \"onSegmentStart\"\n        ]);\n        var animElementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n        var animRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n        var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), ready = _useState[0], setReady = _useState[1];\n        var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(segmentsIn), segments = _useState2[0], setSegments = _useState2[1];\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            if (!fast_deep_equal_es6_react__WEBPACK_IMPORTED_MODULE_2___default()(segments, segmentsIn)) setSegments(segmentsIn);\n        }, [\n            segmentsIn,\n            segments\n        ]);\n        var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(rendererSettingsIn), rendererSettings = _useState3[0], setRendererSettings = _useState3[1];\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            if (!fast_deep_equal_es6_react__WEBPACK_IMPORTED_MODULE_2___default()(rendererSettings, rendererSettingsIn)) setRendererSettings(rendererSettingsIn);\n        }, [\n            rendererSettingsIn,\n            rendererSettings\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            return function() {\n                return animRef.current.removeEventListener(\"complete\", onComplete);\n            };\n        }, [\n            onComplete\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            return function() {\n                return animRef.current.removeEventListener(\"loopComplete\", onLoopComplete);\n            };\n        }, [\n            onLoopComplete\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            return function() {\n                return animRef.current.removeEventListener(\"enterFrame\", onEnterFrame);\n            };\n        }, [\n            onEnterFrame\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            return function() {\n                return animRef.current.removeEventListener(\"segmentStart\", onSegmentStart);\n            };\n        }, [\n            onSegmentStart\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            return function() {\n                return animRef.current.removeEventListener(\"DOMLoaded\", onLoad);\n            };\n        }, [\n            onLoad\n        ]);\n        var setLottieRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(newRef) {\n            animRef.current = newRef;\n            if (forwardedRef) forwardedRef.current = newRef;\n        }, []);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            function parseAnimationData() {\n                if (animationData == null || typeof animationData !== \"object\") return animationData;\n                if (typeof animationData[\"default\"] === \"object\") {\n                    return rfdc_default__WEBPACK_IMPORTED_MODULE_3___default()(animationData[\"default\"]);\n                }\n                return rfdc_default__WEBPACK_IMPORTED_MODULE_3___default()(animationData);\n            }\n            var lottie = loadAnimation({\n                animationData: parseAnimationData(),\n                path: path,\n                container: animElementRef.current,\n                renderer: renderer,\n                loop: false,\n                autoplay: false,\n                rendererSettings: rendererSettings,\n                audioFactory: audioFactory\n            });\n            setLottieRefs(lottie);\n            var onDomLoaded = function onDomLoaded() {\n                return setReady(true);\n            };\n            animRef.current.addEventListener(\"DOMLoaded\", onDomLoaded);\n            return function() {\n                animRef.current.removeEventListener(\"DOMLoaded\", onDomLoaded);\n                setReady(false);\n                animRef.current.destroy();\n                setLottieRefs(undefined);\n            };\n        }, [\n            loop,\n            renderer,\n            rendererSettings,\n            animationData,\n            path,\n            audioFactory,\n            setLottieRefs\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            animRef.current.addEventListener(\"DOMLoaded\", onLoad);\n        }, [\n            onLoad\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            animRef.current.addEventListener(\"complete\", onComplete);\n        }, [\n            onComplete\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            animRef.current.addEventListener(\"loopComplete\", onLoopComplete);\n        }, [\n            onLoopComplete\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            animRef.current.addEventListener(\"enterFrame\", onEnterFrame);\n        }, [\n            onEnterFrame\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            animRef.current.addEventListener(\"segmentStart\", onSegmentStart);\n        }, [\n            onSegmentStart\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            if (!ready) return;\n            animRef.current.loop = loop;\n        }, [\n            ready,\n            loop\n        ]);\n        var wasPlayingSegmentsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            if (!ready) return;\n            function playReverse(lastFrame) {\n                animRef.current.goToAndPlay(lastFrame, true);\n                animRef.current.setDirection(direction);\n            }\n            if (play === true) {\n                var force = true;\n                if (segments) {\n                    animRef.current.playSegments(segments, force);\n                    wasPlayingSegmentsRef.current = true;\n                    if (direction === -1) {\n                        var lastFrame = segments[1];\n                        playReverse(lastFrame);\n                    }\n                } else {\n                    if (wasPlayingSegmentsRef.current) animRef.current.resetSegments(force);\n                    wasPlayingSegmentsRef.current = false;\n                    if (direction === -1) {\n                        var _lastFrame = animRef.current.getDuration(true);\n                        playReverse(_lastFrame);\n                    } else {\n                        animRef.current.play();\n                    }\n                }\n            } else if (play === false) {\n                animRef.current.pause();\n            }\n        }, [\n            play,\n            segments,\n            ready,\n            direction\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            if (!ready) return;\n            if (Number.isNaN(speed)) return;\n            animRef.current.setSpeed(speed);\n        }, [\n            speed,\n            ready\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            if (!ready) return;\n            animRef.current.setDirection(direction);\n        }, [\n            direction,\n            ready\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            if (!ready) return;\n            if (goTo == null) return;\n            var isFrame = true;\n            if (play) animRef.current.goToAndPlay(goTo, isFrame);\n            else animRef.current.goToAndStop(goTo, isFrame);\n        }, [\n            goTo,\n            play,\n            ready\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            if (animRef.current.setSubframe) animRef.current.setSubframe(useSubframes);\n        }, [\n            useSubframes\n        ]);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", _extends({}, props, {\n            ref: animElementRef\n        }));\n    }));\n    Lottie.propTypes = propTypes$1;\n    return Lottie;\n};\nvar LottiePlayer = makeLottiePlayer((lottie_web__WEBPACK_IMPORTED_MODULE_0___default()));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LottiePlayer); //# sourceMappingURL=LottiePlayer.modern.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbG90dGllLXBsYXllci9kaXN0L0xvdHRpZVBsYXllci5tb2Rlcm4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQzBEO0FBQzVDO0FBQ2I7QUFFakMsU0FBU1U7SUFDUEEsV0FBV0MsT0FBT0MsTUFBTSxJQUFJLFNBQVVDLE1BQU07UUFDMUMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFFekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJTixPQUFPUSxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBRUEsT0FBT0w7SUFDVDtJQUVBLE9BQU9ILFNBQVNZLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBRUEsU0FBU1EsOEJBQThCTixNQUFNLEVBQUVPLFFBQVE7SUFDckQsSUFBSVAsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUM1QixJQUFJSixTQUFTLENBQUM7SUFDZCxJQUFJWSxhQUFhZCxPQUFPZSxJQUFJLENBQUNUO0lBQzdCLElBQUlDLEtBQUtKO0lBRVQsSUFBS0EsSUFBSSxHQUFHQSxJQUFJVyxXQUFXVCxNQUFNLEVBQUVGLElBQUs7UUFDdENJLE1BQU1PLFVBQVUsQ0FBQ1gsRUFBRTtRQUNuQixJQUFJVSxTQUFTRyxPQUFPLENBQUNULFFBQVEsR0FBRztRQUNoQ0wsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtJQUMzQjtJQUVBLE9BQU9MO0FBQ1Q7QUFFQSxTQUFTZSxxQkFBcUJDLEVBQUUsRUFBRUMsTUFBTTtJQUN2QyxPQUFPQSxTQUFTO1FBQUVDLFNBQVMsQ0FBQztJQUFFLEdBQUdGLEdBQUdDLFFBQVFBLE9BQU9DLE9BQU8sR0FBR0QsT0FBT0MsT0FBTztBQUM1RTtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxJQUFJQyxJQUFFLGVBQWEsT0FBT0MsVUFBUUEsT0FBT0MsR0FBRyxFQUFDQyxJQUFFSCxJQUFFQyxPQUFPQyxHQUFHLENBQUMsbUJBQWlCLE9BQU1FLElBQUVKLElBQUVDLE9BQU9DLEdBQUcsQ0FBQyxrQkFBZ0IsT0FBTUcsSUFBRUwsSUFBRUMsT0FBT0MsR0FBRyxDQUFDLG9CQUFrQixPQUFNSSxJQUFFTixJQUFFQyxPQUFPQyxHQUFHLENBQUMsdUJBQXFCLE9BQU1LLElBQUVQLElBQUVDLE9BQU9DLEdBQUcsQ0FBQyxvQkFBa0IsT0FBTU0sSUFBRVIsSUFBRUMsT0FBT0MsR0FBRyxDQUFDLG9CQUFrQixPQUFNTyxJQUFFVCxJQUFFQyxPQUFPQyxHQUFHLENBQUMsbUJBQWlCLE9BQU1RLElBQUVWLElBQUVDLE9BQU9DLEdBQUcsQ0FBQyxzQkFBb0IsT0FBTVMsSUFBRVgsSUFBRUMsT0FBT0MsR0FBRyxDQUFDLDJCQUF5QixPQUFNVSxJQUFFWixJQUFFQyxPQUFPQyxHQUFHLENBQUMsdUJBQXFCLE9BQU1XLElBQUViLElBQUVDLE9BQU9DLEdBQUcsQ0FBQyxvQkFBa0IsT0FBTVksSUFBRWQsSUFDdmVDLE9BQU9DLEdBQUcsQ0FBQyx5QkFBdUIsT0FBTWEsSUFBRWYsSUFBRUMsT0FBT0MsR0FBRyxDQUFDLGdCQUFjLE9BQU1jLElBQUVoQixJQUFFQyxPQUFPQyxHQUFHLENBQUMsZ0JBQWMsT0FBTWUsSUFBRWpCLElBQUVDLE9BQU9DLEdBQUcsQ0FBQyxpQkFBZSxPQUFNZ0IsSUFBRWxCLElBQUVDLE9BQU9DLEdBQUcsQ0FBQyx1QkFBcUIsT0FBTWlCLElBQUVuQixJQUFFQyxPQUFPQyxHQUFHLENBQUMscUJBQW1CLE9BQU1rQixJQUFFcEIsSUFBRUMsT0FBT0MsR0FBRyxDQUFDLGlCQUFlO0FBQ2xRLFNBQVNtQixFQUFFQyxDQUFDO0lBQUUsSUFBRyxhQUFXLE9BQU9BLEtBQUcsU0FBT0EsR0FBRTtRQUFDLElBQUlDLElBQUVELEVBQUVFLFFBQVE7UUFBQyxPQUFPRDtZQUFHLEtBQUtwQjtnQkFBRSxPQUFPbUIsSUFBRUEsRUFBRUcsSUFBSSxFQUFDSDtvQkFBRyxLQUFLWjtvQkFBRSxLQUFLQztvQkFBRSxLQUFLTjtvQkFBRSxLQUFLRTtvQkFBRSxLQUFLRDtvQkFBRSxLQUFLTzt3QkFBRSxPQUFPUztvQkFBRTt3QkFBUSxPQUFPQSxJQUFFQSxLQUFHQSxFQUFFRSxRQUFRLEVBQUNGOzRCQUFHLEtBQUtiOzRCQUFFLEtBQUtHOzRCQUFFLEtBQUtJOzRCQUFFLEtBQUtEOzRCQUFFLEtBQUtQO2dDQUFFLE9BQU9jOzRCQUFFO2dDQUFRLE9BQU9DO3dCQUFDO2dCQUFDO1lBQUMsS0FBS25CO2dCQUFFLE9BQU9tQjtRQUFDO0lBQUM7QUFBQztBQUFDLFNBQVNHLEVBQUVKLENBQUM7SUFBRSxPQUFPRCxFQUFFQyxPQUFLWDtBQUFDO0FBQUMsSUFBSWdCLFlBQVVqQjtBQUFFLElBQUlrQixpQkFBZWpCO0FBQUUsSUFBSWtCLGtCQUFnQnBCO0FBQUUsSUFBSXFCLGtCQUFnQnRCO0FBQUUsSUFBSXVCLFVBQVE1QjtBQUFFLElBQUk2QixhQUFXcEI7QUFBRSxJQUFJcUIsV0FBUzVCO0FBQUUsSUFBSTZCLE9BQUtsQjtBQUFFLElBQUltQixPQUFLcEI7QUFBRSxJQUFJcUIsU0FBT2hDO0FBQ3hjLElBQUlpQyxXQUFTOUI7QUFBRSxJQUFJK0IsYUFBV2hDO0FBQUUsSUFBSWlDLFdBQVMxQjtBQUFFLElBQUkyQixjQUFZLFNBQVNsQixDQUFDO0lBQUUsT0FBT0ksRUFBRUosTUFBSUQsRUFBRUMsT0FBS1o7QUFBQztBQUFFLElBQUkrQixtQkFBaUJmO0FBQUUsSUFBSWdCLG9CQUFrQixTQUFTcEIsQ0FBQztJQUFFLE9BQU9ELEVBQUVDLE9BQUtiO0FBQUM7QUFBRSxJQUFJa0Msb0JBQWtCLFNBQVNyQixDQUFDO0lBQUUsT0FBT0QsRUFBRUMsT0FBS2Q7QUFBQztBQUFFLElBQUlvQyxZQUFVLFNBQVN0QixDQUFDO0lBQUUsT0FBTyxhQUFXLE9BQU9BLEtBQUcsU0FBT0EsS0FBR0EsRUFBRUUsUUFBUSxLQUFHckI7QUFBQztBQUFFLElBQUkwQyxlQUFhLFNBQVN2QixDQUFDO0lBQUUsT0FBT0QsRUFBRUMsT0FBS1Y7QUFBQztBQUFFLElBQUlrQyxhQUFXLFNBQVN4QixDQUFDO0lBQUUsT0FBT0QsRUFBRUMsT0FBS2pCO0FBQUM7QUFBRSxJQUFJMEMsU0FBTyxTQUFTekIsQ0FBQztJQUFFLE9BQU9ELEVBQUVDLE9BQUtOO0FBQUM7QUFDL2EsSUFBSWdDLFNBQU8sU0FBUzFCLENBQUM7SUFBRSxPQUFPRCxFQUFFQyxPQUFLUDtBQUFDO0FBQUUsSUFBSWtDLFdBQVMsU0FBUzNCLENBQUM7SUFBRSxPQUFPRCxFQUFFQyxPQUFLbEI7QUFBQztBQUFFLElBQUk4QyxhQUFXLFNBQVM1QixDQUFDO0lBQUUsT0FBT0QsRUFBRUMsT0FBS2Y7QUFBQztBQUFFLElBQUk0QyxlQUFhLFNBQVM3QixDQUFDO0lBQUUsT0FBT0QsRUFBRUMsT0FBS2hCO0FBQUM7QUFBRSxJQUFJOEMsYUFBVyxTQUFTOUIsQ0FBQztJQUFFLE9BQU9ELEVBQUVDLE9BQUtUO0FBQUM7QUFDdE4sSUFBSXdDLHFCQUFtQixTQUFTL0IsQ0FBQztJQUFFLE9BQU8sYUFBVyxPQUFPQSxLQUFHLGVBQWEsT0FBT0EsS0FBR0EsTUFBSWpCLEtBQUdpQixNQUFJWCxLQUFHVyxNQUFJZixLQUFHZSxNQUFJaEIsS0FBR2dCLE1BQUlULEtBQUdTLE1BQUlSLEtBQUcsYUFBVyxPQUFPUSxLQUFHLFNBQU9BLEtBQUlBLENBQUFBLEVBQUVFLFFBQVEsS0FBR1IsS0FBR00sRUFBRUUsUUFBUSxLQUFHVCxLQUFHTyxFQUFFRSxRQUFRLEtBQUdoQixLQUFHYyxFQUFFRSxRQUFRLEtBQUdmLEtBQUdhLEVBQUVFLFFBQVEsS0FBR1osS0FBR1UsRUFBRUUsUUFBUSxLQUFHTixLQUFHSSxFQUFFRSxRQUFRLEtBQUdMLEtBQUdHLEVBQUVFLFFBQVEsS0FBR0osS0FBR0UsRUFBRUUsUUFBUSxLQUFHUCxDQUFBQTtBQUFFO0FBQUUsSUFBSXFDLFNBQU9qQztBQUU1VCxJQUFJa0MseUJBQXlCO0lBQzVCNUIsV0FBV0E7SUFDWEMsZ0JBQWdCQTtJQUNoQkMsaUJBQWlCQTtJQUNqQkMsaUJBQWlCQTtJQUNqQkMsU0FBU0E7SUFDVEMsWUFBWUE7SUFDWkMsVUFBVUE7SUFDVkMsTUFBTUE7SUFDTkMsTUFBTUE7SUFDTkMsUUFBUUE7SUFDUkMsVUFBVUE7SUFDVkMsWUFBWUE7SUFDWkMsVUFBVUE7SUFDVkMsYUFBYUE7SUFDYkMsa0JBQWtCQTtJQUNsQkMsbUJBQW1CQTtJQUNuQkMsbUJBQW1CQTtJQUNuQkMsV0FBV0E7SUFDWEMsY0FBY0E7SUFDZEMsWUFBWUE7SUFDWkMsUUFBUUE7SUFDUkMsUUFBUUE7SUFDUkMsVUFBVUE7SUFDVkMsWUFBWUE7SUFDWkMsY0FBY0E7SUFDZEMsWUFBWUE7SUFDWkMsb0JBQW9CQTtJQUNwQkMsUUFBUUE7QUFDVDtBQUVBLElBQUlFLHNCQUFzQjVELHFCQUFxQixTQUFVRSxNQUFNLEVBQUVDLE9BQU87SUFJeEUsSUFBSTBELElBQXFDLEVBQUU7UUFDeEM7WUFFSCxtRkFBbUY7WUFDbkYsNkRBQTZEO1lBQzdELElBQUlDLFlBQVksT0FBT3pELFdBQVcsY0FBY0EsT0FBT0MsR0FBRztZQUMxRCxJQUFJeUQscUJBQXFCRCxZQUFZekQsT0FBT0MsR0FBRyxDQUFDLG1CQUFtQjtZQUNuRSxJQUFJMEQsb0JBQW9CRixZQUFZekQsT0FBT0MsR0FBRyxDQUFDLGtCQUFrQjtZQUNqRSxJQUFJMkQsc0JBQXNCSCxZQUFZekQsT0FBT0MsR0FBRyxDQUFDLG9CQUFvQjtZQUNyRSxJQUFJNEQseUJBQXlCSixZQUFZekQsT0FBT0MsR0FBRyxDQUFDLHVCQUF1QjtZQUMzRSxJQUFJNkQsc0JBQXNCTCxZQUFZekQsT0FBT0MsR0FBRyxDQUFDLG9CQUFvQjtZQUNyRSxJQUFJOEQsc0JBQXNCTixZQUFZekQsT0FBT0MsR0FBRyxDQUFDLG9CQUFvQjtZQUNyRSxJQUFJK0QscUJBQXFCUCxZQUFZekQsT0FBT0MsR0FBRyxDQUFDLG1CQUFtQixRQUFRLDhFQUE4RTtZQUN6SixxRUFBcUU7WUFFckUsSUFBSWdFLHdCQUF3QlIsWUFBWXpELE9BQU9DLEdBQUcsQ0FBQyxzQkFBc0I7WUFDekUsSUFBSWlFLDZCQUE2QlQsWUFBWXpELE9BQU9DLEdBQUcsQ0FBQywyQkFBMkI7WUFDbkYsSUFBSWtFLHlCQUF5QlYsWUFBWXpELE9BQU9DLEdBQUcsQ0FBQyx1QkFBdUI7WUFDM0UsSUFBSW1FLHNCQUFzQlgsWUFBWXpELE9BQU9DLEdBQUcsQ0FBQyxvQkFBb0I7WUFDckUsSUFBSW9FLDJCQUEyQlosWUFBWXpELE9BQU9DLEdBQUcsQ0FBQyx5QkFBeUI7WUFDL0UsSUFBSXFFLGtCQUFrQmIsWUFBWXpELE9BQU9DLEdBQUcsQ0FBQyxnQkFBZ0I7WUFDN0QsSUFBSXNFLGtCQUFrQmQsWUFBWXpELE9BQU9DLEdBQUcsQ0FBQyxnQkFBZ0I7WUFDN0QsSUFBSXVFLG1CQUFtQmYsWUFBWXpELE9BQU9DLEdBQUcsQ0FBQyxpQkFBaUI7WUFDL0QsSUFBSXdFLHlCQUF5QmhCLFlBQVl6RCxPQUFPQyxHQUFHLENBQUMsdUJBQXVCO1lBQzNFLElBQUl5RSx1QkFBdUJqQixZQUFZekQsT0FBT0MsR0FBRyxDQUFDLHFCQUFxQjtZQUN2RSxJQUFJMEUsbUJBQW1CbEIsWUFBWXpELE9BQU9DLEdBQUcsQ0FBQyxpQkFBaUI7WUFFL0QsU0FBU21ELG1CQUFtQjVCLElBQUk7Z0JBQzlCLE9BQU8sT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsY0FBYyxnRkFBZ0Y7Z0JBQ2pKQSxTQUFTb0MsdUJBQXVCcEMsU0FBUzBDLDhCQUE4QjFDLFNBQVNzQyx1QkFBdUJ0QyxTQUFTcUMsMEJBQTBCckMsU0FBUzRDLHVCQUF1QjVDLFNBQVM2Qyw0QkFBNEIsT0FBTzdDLFNBQVMsWUFBWUEsU0FBUyxRQUFTQSxDQUFBQSxLQUFLRCxRQUFRLEtBQUtnRCxtQkFBbUIvQyxLQUFLRCxRQUFRLEtBQUsrQyxtQkFBbUI5QyxLQUFLRCxRQUFRLEtBQUt3Qyx1QkFBdUJ2QyxLQUFLRCxRQUFRLEtBQUt5QyxzQkFBc0J4QyxLQUFLRCxRQUFRLEtBQUs0QywwQkFBMEIzQyxLQUFLRCxRQUFRLEtBQUtrRCwwQkFBMEJqRCxLQUFLRCxRQUFRLEtBQUttRCx3QkFBd0JsRCxLQUFLRCxRQUFRLEtBQUtvRCxvQkFBb0JuRCxLQUFLRCxRQUFRLEtBQUtpRCxnQkFBZTtZQUNubUI7WUFFQSxTQUFTbkIsT0FBT3VCLE1BQU07Z0JBQ3BCLElBQUksT0FBT0EsV0FBVyxZQUFZQSxXQUFXLE1BQU07b0JBQ2pELElBQUlyRCxXQUFXcUQsT0FBT3JELFFBQVE7b0JBRTlCLE9BQVFBO3dCQUNOLEtBQUttQzs0QkFDSCxJQUFJbEMsT0FBT29ELE9BQU9wRCxJQUFJOzRCQUV0QixPQUFRQTtnQ0FDTixLQUFLeUM7Z0NBQ0wsS0FBS0M7Z0NBQ0wsS0FBS047Z0NBQ0wsS0FBS0U7Z0NBQ0wsS0FBS0Q7Z0NBQ0wsS0FBS087b0NBQ0gsT0FBTzVDO2dDQUVUO29DQUNFLElBQUlxRCxlQUFlckQsUUFBUUEsS0FBS0QsUUFBUTtvQ0FFeEMsT0FBUXNEO3dDQUNOLEtBQUtiO3dDQUNMLEtBQUtHO3dDQUNMLEtBQUtJO3dDQUNMLEtBQUtEO3dDQUNMLEtBQUtQOzRDQUNILE9BQU9jO3dDQUVUOzRDQUNFLE9BQU90RDtvQ0FDWDs0QkFFSjt3QkFFRixLQUFLb0M7NEJBQ0gsT0FBT3BDO29CQUNYO2dCQUNGO2dCQUVBLE9BQU91RDtZQUNULEVBQUUsaURBQWlEO1lBRW5ELElBQUlwRCxZQUFZdUM7WUFDaEIsSUFBSXRDLGlCQUFpQnVDO1lBQ3JCLElBQUl0QyxrQkFBa0JvQztZQUN0QixJQUFJbkMsa0JBQWtCa0M7WUFDdEIsSUFBSWpDLFVBQVU0QjtZQUNkLElBQUkzQixhQUFhb0M7WUFDakIsSUFBSW5DLFdBQVc0QjtZQUNmLElBQUkzQixPQUFPc0M7WUFDWCxJQUFJckMsT0FBT29DO1lBQ1gsSUFBSW5DLFNBQVN3QjtZQUNiLElBQUl2QixXQUFXMEI7WUFDZixJQUFJekIsYUFBYXdCO1lBQ2pCLElBQUl2QixXQUFXOEI7WUFDZixJQUFJVyxzQ0FBc0MsT0FBTyxpQ0FBaUM7WUFFbEYsU0FBU3hDLFlBQVlxQyxNQUFNO2dCQUN6QjtvQkFDRSxJQUFJLENBQUNHLHFDQUFxQzt3QkFDeENBLHNDQUFzQyxNQUFNLGtEQUFrRDt3QkFFOUZDLE9BQU8sQ0FBQyxPQUFPLENBQUMsMERBQTBELCtEQUErRDtvQkFDM0k7Z0JBQ0Y7Z0JBRUEsT0FBT3hDLGlCQUFpQm9DLFdBQVd2QixPQUFPdUIsWUFBWVg7WUFDeEQ7WUFDQSxTQUFTekIsaUJBQWlCb0MsTUFBTTtnQkFDOUIsT0FBT3ZCLE9BQU91QixZQUFZVjtZQUM1QjtZQUNBLFNBQVN6QixrQkFBa0JtQyxNQUFNO2dCQUMvQixPQUFPdkIsT0FBT3VCLFlBQVlaO1lBQzVCO1lBQ0EsU0FBU3RCLGtCQUFrQmtDLE1BQU07Z0JBQy9CLE9BQU92QixPQUFPdUIsWUFBWWI7WUFDNUI7WUFDQSxTQUFTcEIsVUFBVWlDLE1BQU07Z0JBQ3ZCLE9BQU8sT0FBT0EsV0FBVyxZQUFZQSxXQUFXLFFBQVFBLE9BQU9yRCxRQUFRLEtBQUttQztZQUM5RTtZQUNBLFNBQVNkLGFBQWFnQyxNQUFNO2dCQUMxQixPQUFPdkIsT0FBT3VCLFlBQVlUO1lBQzVCO1lBQ0EsU0FBU3RCLFdBQVcrQixNQUFNO2dCQUN4QixPQUFPdkIsT0FBT3VCLFlBQVloQjtZQUM1QjtZQUNBLFNBQVNkLE9BQU84QixNQUFNO2dCQUNwQixPQUFPdkIsT0FBT3VCLFlBQVlMO1lBQzVCO1lBQ0EsU0FBU3hCLE9BQU82QixNQUFNO2dCQUNwQixPQUFPdkIsT0FBT3VCLFlBQVlOO1lBQzVCO1lBQ0EsU0FBU3RCLFNBQVM0QixNQUFNO2dCQUN0QixPQUFPdkIsT0FBT3VCLFlBQVlqQjtZQUM1QjtZQUNBLFNBQVNWLFdBQVcyQixNQUFNO2dCQUN4QixPQUFPdkIsT0FBT3VCLFlBQVlkO1lBQzVCO1lBQ0EsU0FBU1osYUFBYTBCLE1BQU07Z0JBQzFCLE9BQU92QixPQUFPdUIsWUFBWWY7WUFDNUI7WUFDQSxTQUFTVixXQUFXeUIsTUFBTTtnQkFDeEIsT0FBT3ZCLE9BQU91QixZQUFZUjtZQUM1QjtZQUVBdEUsUUFBUTRCLFNBQVMsR0FBR0E7WUFDcEI1QixRQUFRNkIsY0FBYyxHQUFHQTtZQUN6QjdCLFFBQVE4QixlQUFlLEdBQUdBO1lBQzFCOUIsUUFBUStCLGVBQWUsR0FBR0E7WUFDMUIvQixRQUFRZ0MsT0FBTyxHQUFHQTtZQUNsQmhDLFFBQVFpQyxVQUFVLEdBQUdBO1lBQ3JCakMsUUFBUWtDLFFBQVEsR0FBR0E7WUFDbkJsQyxRQUFRbUMsSUFBSSxHQUFHQTtZQUNmbkMsUUFBUW9DLElBQUksR0FBR0E7WUFDZnBDLFFBQVFxQyxNQUFNLEdBQUdBO1lBQ2pCckMsUUFBUXNDLFFBQVEsR0FBR0E7WUFDbkJ0QyxRQUFRdUMsVUFBVSxHQUFHQTtZQUNyQnZDLFFBQVF3QyxRQUFRLEdBQUdBO1lBQ25CeEMsUUFBUXlDLFdBQVcsR0FBR0E7WUFDdEJ6QyxRQUFRMEMsZ0JBQWdCLEdBQUdBO1lBQzNCMUMsUUFBUTJDLGlCQUFpQixHQUFHQTtZQUM1QjNDLFFBQVE0QyxpQkFBaUIsR0FBR0E7WUFDNUI1QyxRQUFRNkMsU0FBUyxHQUFHQTtZQUNwQjdDLFFBQVE4QyxZQUFZLEdBQUdBO1lBQ3ZCOUMsUUFBUStDLFVBQVUsR0FBR0E7WUFDckIvQyxRQUFRZ0QsTUFBTSxHQUFHQTtZQUNqQmhELFFBQVFpRCxNQUFNLEdBQUdBO1lBQ2pCakQsUUFBUWtELFFBQVEsR0FBR0E7WUFDbkJsRCxRQUFRbUQsVUFBVSxHQUFHQTtZQUNyQm5ELFFBQVFvRCxZQUFZLEdBQUdBO1lBQ3ZCcEQsUUFBUXFELFVBQVUsR0FBR0E7WUFDckJyRCxRQUFRc0Qsa0JBQWtCLEdBQUdBO1lBQzdCdEQsUUFBUXVELE1BQU0sR0FBR0E7UUFDZjtJQUNGO0FBQ0E7QUFFQSxJQUFJNEIsVUFBVXRGLHFCQUFxQixTQUFVRSxNQUFNO0lBRW5ELElBQUkyRCxLQUF5QixFQUFjLEVBRTFDLE1BQU07UUFDTDNELE9BQU9DLE9BQU8sR0FBR3lEO0lBQ25CO0FBQ0E7QUFFQTs7OztBQUlBLEdBQ0EsaUNBQWlDLEdBQ2pDLElBQUkyQix3QkFBd0J4RyxPQUFPd0cscUJBQXFCO0FBQ3hELElBQUkvRixpQkFBaUJULE9BQU9RLFNBQVMsQ0FBQ0MsY0FBYztBQUNwRCxJQUFJZ0csbUJBQW1CekcsT0FBT1EsU0FBUyxDQUFDa0csb0JBQW9CO0FBRTVELFNBQVNDLFNBQVNDLEdBQUc7SUFDcEIsSUFBSUEsUUFBUSxRQUFRQSxRQUFRUixXQUFXO1FBQ3RDLE1BQU0sSUFBSVMsVUFBVTtJQUNyQjtJQUVBLE9BQU83RyxPQUFPNEc7QUFDZjtBQUVBLFNBQVNFO0lBQ1IsSUFBSTtRQUNILElBQUksQ0FBQzlHLE9BQU9DLE1BQU0sRUFBRTtZQUNuQixPQUFPO1FBQ1I7UUFFQSxnRUFBZ0U7UUFFaEUsdURBQXVEO1FBQ3ZELElBQUk4RyxRQUFRLElBQUlDLE9BQU8sUUFBUyxzQ0FBc0M7UUFDdEVELEtBQUssQ0FBQyxFQUFFLEdBQUc7UUFDWCxJQUFJL0csT0FBT2lILG1CQUFtQixDQUFDRixNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUs7WUFDakQsT0FBTztRQUNSO1FBRUEsdURBQXVEO1FBQ3ZELElBQUlHLFFBQVEsQ0FBQztRQUNiLElBQUssSUFBSS9HLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1lBQzVCK0csS0FBSyxDQUFDLE1BQU1GLE9BQU9HLFlBQVksQ0FBQ2hILEdBQUcsR0FBR0E7UUFDdkM7UUFDQSxJQUFJaUgsU0FBU3BILE9BQU9pSCxtQkFBbUIsQ0FBQ0MsT0FBT0csR0FBRyxDQUFDLFNBQVVwRixDQUFDO1lBQzdELE9BQU9pRixLQUFLLENBQUNqRixFQUFFO1FBQ2hCO1FBQ0EsSUFBSW1GLE9BQU9FLElBQUksQ0FBQyxRQUFRLGNBQWM7WUFDckMsT0FBTztRQUNSO1FBRUEsdURBQXVEO1FBQ3ZELElBQUlDLFFBQVEsQ0FBQztRQUNiLHVCQUF1QkMsS0FBSyxDQUFDLElBQUlDLE9BQU8sQ0FBQyxTQUFVQyxNQUFNO1lBQ3hESCxLQUFLLENBQUNHLE9BQU8sR0FBR0E7UUFDakI7UUFDQSxJQUFJMUgsT0FBT2UsSUFBSSxDQUFDZixPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHc0gsUUFBUUQsSUFBSSxDQUFDLFFBQzdDLHdCQUF3QjtZQUN6QixPQUFPO1FBQ1I7UUFFQSxPQUFPO0lBQ1IsRUFBRSxPQUFPSyxLQUFLO1FBQ2Isb0VBQW9FO1FBQ3BFLE9BQU87SUFDUjtBQUNEO0FBRUEsSUFBSUMsZUFBZWQsb0JBQW9COUcsT0FBT0MsTUFBTSxHQUFHLFNBQVVDLE1BQU0sRUFBRUksTUFBTTtJQUM5RSxJQUFJdUg7SUFDSixJQUFJQyxLQUFLbkIsU0FBU3pHO0lBQ2xCLElBQUk2SDtJQUVKLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJNUgsVUFBVUMsTUFBTSxFQUFFMkgsSUFBSztRQUMxQ0gsT0FBTzdILE9BQU9JLFNBQVMsQ0FBQzRILEVBQUU7UUFFMUIsSUFBSyxJQUFJekgsT0FBT3NILEtBQU07WUFDckIsSUFBSXBILGVBQWVDLElBQUksQ0FBQ21ILE1BQU10SCxNQUFNO2dCQUNuQ3VILEVBQUUsQ0FBQ3ZILElBQUksR0FBR3NILElBQUksQ0FBQ3RILElBQUk7WUFDcEI7UUFDRDtRQUVBLElBQUlpRyx1QkFBdUI7WUFDMUJ1QixVQUFVdkIsc0JBQXNCcUI7WUFDaEMsSUFBSyxJQUFJMUgsSUFBSSxHQUFHQSxJQUFJNEgsUUFBUTFILE1BQU0sRUFBRUYsSUFBSztnQkFDeEMsSUFBSXNHLGlCQUFpQi9GLElBQUksQ0FBQ21ILE1BQU1FLE9BQU8sQ0FBQzVILEVBQUUsR0FBRztvQkFDNUMySCxFQUFFLENBQUNDLE9BQU8sQ0FBQzVILEVBQUUsQ0FBQyxHQUFHMEgsSUFBSSxDQUFDRSxPQUFPLENBQUM1SCxFQUFFLENBQUM7Z0JBQ2xDO1lBQ0Q7UUFDRDtJQUNEO0lBRUEsT0FBTzJIO0FBQ1I7QUFFQTs7Ozs7Q0FLQyxHQUVELElBQUlHLHVCQUF1QjtBQUUzQixJQUFJQyx5QkFBeUJEO0FBRTdCLElBQUlFLE1BQU1DLFNBQVMxSCxJQUFJLENBQUMySCxJQUFJLENBQUNySSxPQUFPUSxTQUFTLENBQUNDLGNBQWM7QUFFNUQsSUFBSTZILGVBQWUsWUFBWTtBQUUvQixJQUFJeEQsSUFBeUIsRUFBYztJQUN6QyxJQUFJeUQseUJBQXlCTDtJQUM3QixJQUFJTSxxQkFBcUIsQ0FBQztJQUMxQixJQUFJQyxRQUFRTjtJQUVaRyxlQUFlLFNBQVNJLElBQUk7UUFDMUIsSUFBSUMsVUFBVSxjQUFjRDtRQUM1QixJQUFJLE9BQU9wQyxZQUFZLGFBQWE7WUFDbENBLFFBQVFzQyxLQUFLLENBQUNEO1FBQ2hCO1FBQ0EsSUFBSTtZQUNGLHFDQUFxQztZQUNyQyx3RUFBd0U7WUFDeEUseURBQXlEO1lBQ3pELE1BQU0sSUFBSUUsTUFBTUY7UUFDbEIsRUFBRSxPQUFPbkcsR0FBRyxDQUFPO0lBQ3JCO0FBQ0Y7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU3NHLGVBQWVDLFNBQVMsRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsUUFBUTtJQUMxRSxJQUFJckUsSUFBeUIsRUFBYztRQUN6QyxJQUFLLElBQUlzRSxnQkFBZ0JMLFVBQVc7WUFDbEMsSUFBSU4sTUFBTU0sV0FBV0ssZUFBZTtnQkFDbEMsSUFBSVI7Z0JBQ0osb0VBQW9FO2dCQUNwRSxtRUFBbUU7Z0JBQ25FLDBEQUEwRDtnQkFDMUQsSUFBSTtvQkFDRixxRUFBcUU7b0JBQ3JFLG1FQUFtRTtvQkFDbkUsSUFBSSxPQUFPRyxTQUFTLENBQUNLLGFBQWEsS0FBSyxZQUFZO3dCQUNqRCxJQUFJekIsTUFBTWtCLE1BQ1IsQ0FBQ0ssaUJBQWlCLGFBQVksSUFBSyxPQUFPRCxXQUFXLFlBQVlHLGVBQWUsbUJBQ2hGLGlGQUFpRixPQUFPTCxTQUFTLENBQUNLLGFBQWEsR0FBRyxPQUNsSDt3QkFFRnpCLElBQUkwQixJQUFJLEdBQUc7d0JBQ1gsTUFBTTFCO29CQUNSO29CQUNBaUIsUUFBUUcsU0FBUyxDQUFDSyxhQUFhLENBQUNKLFFBQVFJLGNBQWNGLGVBQWVELFVBQVUsTUFBTVY7Z0JBQ3ZGLEVBQUUsT0FBT2UsSUFBSTtvQkFDWFYsUUFBUVU7Z0JBQ1Y7Z0JBQ0EsSUFBSVYsU0FBUyxDQUFFQSxDQUFBQSxpQkFBaUJDLEtBQUksR0FBSTtvQkFDdENQLGFBQ0UsQ0FBQ1ksaUJBQWlCLGFBQVksSUFBSyw2QkFDbkNELFdBQVcsT0FBT0csZUFBZSxvQ0FDakMsOERBQThELE9BQU9SLFFBQVEsT0FDN0Usb0VBQ0EsbUVBQ0E7Z0JBRUo7Z0JBQ0EsSUFBSUEsaUJBQWlCQyxTQUFTLENBQUVELENBQUFBLE1BQU1ELE9BQU8sSUFBSUgsa0JBQWlCLEdBQUk7b0JBQ3BFLHdFQUF3RTtvQkFDeEUsY0FBYztvQkFDZEEsa0JBQWtCLENBQUNJLE1BQU1ELE9BQU8sQ0FBQyxHQUFHO29CQUVwQyxJQUFJWSxRQUFRSixXQUFXQSxhQUFhO29CQUVwQ2IsYUFDRSxZQUFZVyxXQUFXLFlBQVlMLE1BQU1ELE9BQU8sR0FBSVksQ0FBQUEsU0FBUyxPQUFPQSxRQUFRLEVBQUM7Z0JBRWpGO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0RULGVBQWVVLGlCQUFpQixHQUFHO0lBQ2pDLElBQUkxRSxJQUF5QixFQUFjO1FBQ3pDMEQscUJBQXFCLENBQUM7SUFDeEI7QUFDRjtBQUVBLElBQUlpQixtQkFBbUJYO0FBRXZCLElBQUlZLGlCQUFpQixZQUFZO0FBRWpDLElBQUk1RSxJQUF5QixFQUFjO0lBQ3pDNEUsaUJBQWlCLFNBQVNoQixJQUFJO1FBQzVCLElBQUlDLFVBQVUsY0FBY0Q7UUFDNUIsSUFBSSxPQUFPcEMsWUFBWSxhQUFhO1lBQ2xDQSxRQUFRc0MsS0FBSyxDQUFDRDtRQUNoQjtRQUNBLElBQUk7WUFDRixxQ0FBcUM7WUFDckMsd0VBQXdFO1lBQ3hFLHlEQUF5RDtZQUN6RCxNQUFNLElBQUlFLE1BQU1GO1FBQ2xCLEVBQUUsT0FBT25HLEdBQUcsQ0FBQztJQUNmO0FBQ0Y7QUFFQSxTQUFTbUg7SUFDUCxPQUFPO0FBQ1Q7QUFFQSxJQUFJQywwQkFBMEIsU0FBU0MsY0FBYyxFQUFFQyxtQkFBbUI7SUFDeEUsaUJBQWlCLEdBQ2pCLElBQUlDLGtCQUFrQixPQUFPekksV0FBVyxjQUFjQSxPQUFPMEksUUFBUTtJQUNyRSxJQUFJQyx1QkFBdUIsY0FBYyxzQkFBc0I7SUFFL0Q7Ozs7Ozs7Ozs7Ozs7R0FhQyxHQUNELFNBQVNDLGNBQWNDLGFBQWE7UUFDbEMsSUFBSUMsYUFBYUQsaUJBQWtCSixDQUFBQSxtQkFBbUJJLGFBQWEsQ0FBQ0osZ0JBQWdCLElBQUlJLGFBQWEsQ0FBQ0YscUJBQXFCO1FBQzNILElBQUksT0FBT0csZUFBZSxZQUFZO1lBQ3BDLE9BQU9BO1FBQ1Q7SUFDRjtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E2Q0MsR0FFRCxJQUFJQyxZQUFZO0lBRWhCLGFBQWE7SUFDYixxRkFBcUY7SUFDckYsSUFBSUMsaUJBQWlCO1FBQ25CQyxPQUFPQywyQkFBMkI7UUFDbENDLFFBQVFELDJCQUEyQjtRQUNuQ0UsTUFBTUYsMkJBQTJCO1FBQ2pDRyxNQUFNSCwyQkFBMkI7UUFDakNJLFFBQVFKLDJCQUEyQjtRQUNuQ3RFLFFBQVFzRSwyQkFBMkI7UUFDbkNLLFFBQVFMLDJCQUEyQjtRQUNuQ00sUUFBUU4sMkJBQTJCO1FBRW5DTyxLQUFLQztRQUNMQyxTQUFTQztRQUNUQyxTQUFTQztRQUNUQyxhQUFhQztRQUNiQyxZQUFZQztRQUNaQyxNQUFNQztRQUNOQyxVQUFVQztRQUNWQyxPQUFPQztRQUNQQyxXQUFXQztRQUNYQyxPQUFPQztRQUNQQyxPQUFPQztJQUNUO0lBRUE7OztHQUdDLEdBQ0QsZ0NBQWdDLEdBQ2hDLFNBQVNDLEdBQUc3SixDQUFDLEVBQUVDLENBQUM7UUFDZCxzQkFBc0I7UUFDdEIsSUFBSUQsTUFBTUMsR0FBRztZQUNYLGtCQUFrQjtZQUNsQiwwQkFBMEI7WUFDMUIsT0FBT0QsTUFBTSxLQUFLLElBQUlBLE1BQU0sSUFBSUM7UUFDbEMsT0FBTztZQUNMLHVCQUF1QjtZQUN2QixPQUFPRCxNQUFNQSxLQUFLQyxNQUFNQTtRQUMxQjtJQUNGO0lBQ0EsK0JBQStCLEdBRS9COzs7Ozs7R0FNQyxHQUNELFNBQVM2SixjQUFjM0QsT0FBTyxFQUFFNEQsSUFBSTtRQUNsQyxJQUFJLENBQUM1RCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDNEQsSUFBSSxHQUFHQSxRQUFRLE9BQU9BLFNBQVMsV0FBV0EsT0FBTSxDQUFDO1FBQ3RELElBQUksQ0FBQ2hELEtBQUssR0FBRztJQUNmO0lBQ0EsMERBQTBEO0lBQzFEK0MsY0FBYzlMLFNBQVMsR0FBR3FJLE1BQU1ySSxTQUFTO0lBRXpDLFNBQVNnTSwyQkFBMkJDLFFBQVE7UUFDMUMsSUFBSTNILElBQXlCLEVBQWM7WUFDekMsSUFBSTRILDBCQUEwQixDQUFDO1lBQy9CLElBQUlDLDZCQUE2QjtRQUNuQztRQUNBLFNBQVNDLFVBQVVDLFVBQVUsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUU3RCxhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVksRUFBRUMsTUFBTTtZQUMzRi9ELGdCQUFnQkEsaUJBQWlCbUI7WUFDakMyQyxlQUFlQSxnQkFBZ0JEO1lBRS9CLElBQUlFLFdBQVcvRSx3QkFBd0I7Z0JBQ3JDLElBQUk0QixxQkFBcUI7b0JBQ3ZCLHNEQUFzRDtvQkFDdEQsSUFBSW5DLE1BQU0sSUFBSWtCLE1BQ1oseUZBQ0Esb0RBQ0E7b0JBRUZsQixJQUFJMEIsSUFBSSxHQUFHO29CQUNYLE1BQU0xQjtnQkFDUixPQUFPLElBQUk3QyxLQUF5QixJQUFnQixPQUFPd0IsWUFBWSxhQUFhO29CQUNsRixnREFBZ0Q7b0JBQ2hELElBQUk0RyxXQUFXaEUsZ0JBQWdCLE1BQU02RDtvQkFDckMsSUFDRSxDQUFDTCx1QkFBdUIsQ0FBQ1EsU0FBUyxJQUNsQywwRkFBMEY7b0JBQzFGUCw2QkFBNkIsR0FDN0I7d0JBQ0FqRCxlQUNFLDJEQUNBLHVCQUF1QnNELGVBQWUsZ0JBQWdCOUQsZ0JBQWdCLDJCQUN0RSw0REFDQSxtRUFDQSxrRUFBa0U7d0JBRXBFd0QsdUJBQXVCLENBQUNRLFNBQVMsR0FBRzt3QkFDcENQO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJRyxLQUFLLENBQUNDLFNBQVMsSUFBSSxNQUFNO2dCQUMzQixJQUFJRixZQUFZO29CQUNkLElBQUlDLEtBQUssQ0FBQ0MsU0FBUyxLQUFLLE1BQU07d0JBQzVCLE9BQU8sSUFBSVQsY0FBYyxTQUFTckQsV0FBVyxPQUFPK0QsZUFBZSw2QkFBOEIsVUFBUzlELGdCQUFnQiw2QkFBNEI7b0JBQ3hKO29CQUNBLE9BQU8sSUFBSW9ELGNBQWMsU0FBU3JELFdBQVcsT0FBTytELGVBQWUsZ0NBQWlDLE9BQU05RCxnQkFBZ0Isa0NBQWlDO2dCQUM3SjtnQkFDQSxPQUFPO1lBQ1QsT0FBTztnQkFDTCxPQUFPdUQsU0FBU0ssT0FBT0MsVUFBVTdELGVBQWVELFVBQVUrRDtZQUM1RDtRQUNGO1FBRUEsSUFBSUcsbUJBQW1CUCxVQUFVdkUsSUFBSSxDQUFDLE1BQU07UUFDNUM4RSxpQkFBaUJOLFVBQVUsR0FBR0QsVUFBVXZFLElBQUksQ0FBQyxNQUFNO1FBRW5ELE9BQU84RTtJQUNUO0lBRUEsU0FBUzNDLDJCQUEyQjRDLFlBQVk7UUFDOUMsU0FBU1gsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUU3RCxhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVksRUFBRUMsTUFBTTtZQUM5RSxJQUFJSSxZQUFZUCxLQUFLLENBQUNDLFNBQVM7WUFDL0IsSUFBSU8sV0FBV0MsWUFBWUY7WUFDM0IsSUFBSUMsYUFBYUYsY0FBYztnQkFDN0IscUVBQXFFO2dCQUNyRSx3RUFBd0U7Z0JBQ3hFLHNCQUFzQjtnQkFDdEIsSUFBSUksY0FBY0MsZUFBZUo7Z0JBRWpDLE9BQU8sSUFBSWYsY0FDVCxhQUFhckQsV0FBVyxPQUFPK0QsZUFBZSxlQUFnQixPQUFNUSxjQUFjLG9CQUFvQnRFLGdCQUFnQixjQUFhLElBQU0sT0FBTWtFLGVBQWUsSUFBRyxHQUNqSztvQkFBQ0EsY0FBY0E7Z0JBQVk7WUFFL0I7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxPQUFPWiwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU3pCO1FBQ1AsT0FBT3dCLDJCQUEyQjdDO0lBQ3BDO0lBRUEsU0FBU3VCLHlCQUF5QndDLFdBQVc7UUFDM0MsU0FBU2pCLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFN0QsYUFBYSxFQUFFRCxRQUFRLEVBQUUrRCxZQUFZO1lBQ3RFLElBQUksT0FBT1UsZ0JBQWdCLFlBQVk7Z0JBQ3JDLE9BQU8sSUFBSXBCLGNBQWMsZUFBZVUsZUFBZSxxQkFBcUI5RCxnQkFBZ0I7WUFDOUY7WUFDQSxJQUFJbUUsWUFBWVAsS0FBSyxDQUFDQyxTQUFTO1lBQy9CLElBQUksQ0FBQ1ksTUFBTUMsT0FBTyxDQUFDUCxZQUFZO2dCQUM3QixJQUFJQyxXQUFXQyxZQUFZRjtnQkFDM0IsT0FBTyxJQUFJZixjQUFjLGFBQWFyRCxXQUFXLE9BQU8rRCxlQUFlLGVBQWdCLE9BQU1NLFdBQVcsb0JBQW9CcEUsZ0JBQWdCLHVCQUFzQjtZQUNwSztZQUNBLElBQUssSUFBSS9JLElBQUksR0FBR0EsSUFBSWtOLFVBQVVoTixNQUFNLEVBQUVGLElBQUs7Z0JBQ3pDLElBQUl5SSxRQUFROEUsWUFBWUwsV0FBV2xOLEdBQUcrSSxlQUFlRCxVQUFVK0QsZUFBZSxNQUFNN00sSUFBSSxLQUFLK0g7Z0JBQzdGLElBQUlVLGlCQUFpQkMsT0FBTztvQkFDMUIsT0FBT0Q7Z0JBQ1Q7WUFDRjtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU80RCwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU3JCO1FBQ1AsU0FBU3FCLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFN0QsYUFBYSxFQUFFRCxRQUFRLEVBQUUrRCxZQUFZO1lBQ3RFLElBQUlLLFlBQVlQLEtBQUssQ0FBQ0MsU0FBUztZQUMvQixJQUFJLENBQUNsRCxlQUFld0QsWUFBWTtnQkFDOUIsSUFBSUMsV0FBV0MsWUFBWUY7Z0JBQzNCLE9BQU8sSUFBSWYsY0FBYyxhQUFhckQsV0FBVyxPQUFPK0QsZUFBZSxlQUFnQixPQUFNTSxXQUFXLG9CQUFvQnBFLGdCQUFnQixvQ0FBbUM7WUFDakw7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxPQUFPc0QsMkJBQTJCQztJQUNwQztJQUVBLFNBQVNuQjtRQUNQLFNBQVNtQixTQUFTSyxLQUFLLEVBQUVDLFFBQVEsRUFBRTdELGFBQWEsRUFBRUQsUUFBUSxFQUFFK0QsWUFBWTtZQUN0RSxJQUFJSyxZQUFZUCxLQUFLLENBQUNDLFNBQVM7WUFDL0IsSUFBSSxDQUFDeEcsUUFBUTdCLGtCQUFrQixDQUFDMkksWUFBWTtnQkFDMUMsSUFBSUMsV0FBV0MsWUFBWUY7Z0JBQzNCLE9BQU8sSUFBSWYsY0FBYyxhQUFhckQsV0FBVyxPQUFPK0QsZUFBZSxlQUFnQixPQUFNTSxXQUFXLG9CQUFvQnBFLGdCQUFnQix5Q0FBd0M7WUFDdEw7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxPQUFPc0QsMkJBQTJCQztJQUNwQztJQUVBLFNBQVNqQiwwQkFBMEJxQyxhQUFhO1FBQzlDLFNBQVNwQixTQUFTSyxLQUFLLEVBQUVDLFFBQVEsRUFBRTdELGFBQWEsRUFBRUQsUUFBUSxFQUFFK0QsWUFBWTtZQUN0RSxJQUFJLENBQUVGLENBQUFBLEtBQUssQ0FBQ0MsU0FBUyxZQUFZYyxhQUFZLEdBQUk7Z0JBQy9DLElBQUlDLG9CQUFvQkQsY0FBY3hFLElBQUksSUFBSWdCO2dCQUM5QyxJQUFJMEQsa0JBQWtCQyxhQUFhbEIsS0FBSyxDQUFDQyxTQUFTO2dCQUNsRCxPQUFPLElBQUlULGNBQWMsYUFBYXJELFdBQVcsT0FBTytELGVBQWUsZUFBZ0IsT0FBTWUsa0JBQWtCLG9CQUFvQjdFLGdCQUFnQixjQUFhLElBQU0sbUJBQWtCNEUsb0JBQW9CLElBQUc7WUFDak47WUFDQSxPQUFPO1FBQ1Q7UUFDQSxPQUFPdEIsMkJBQTJCQztJQUNwQztJQUVBLFNBQVNYLHNCQUFzQm1DLGNBQWM7UUFDM0MsSUFBSSxDQUFDTixNQUFNQyxPQUFPLENBQUNLLGlCQUFpQjtZQUNsQyxJQUFJbkosSUFBeUIsRUFBYztnQkFDekMsSUFBSTFFLFVBQVVDLE1BQU0sR0FBRyxHQUFHO29CQUN4QnFKLGVBQ0UsaUVBQWlFdEosVUFBVUMsTUFBTSxHQUFHLGlCQUNwRjtnQkFFSixPQUFPO29CQUNMcUosZUFBZTtnQkFDakI7WUFDRjtZQUNBLE9BQU9DO1FBQ1Q7UUFFQSxTQUFTOEMsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUU3RCxhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVk7WUFDdEUsSUFBSUssWUFBWVAsS0FBSyxDQUFDQyxTQUFTO1lBQy9CLElBQUssSUFBSTVNLElBQUksR0FBR0EsSUFBSThOLGVBQWU1TixNQUFNLEVBQUVGLElBQUs7Z0JBQzlDLElBQUlrTSxHQUFHZ0IsV0FBV1ksY0FBYyxDQUFDOU4sRUFBRSxHQUFHO29CQUNwQyxPQUFPO2dCQUNUO1lBQ0Y7WUFFQSxJQUFJK04sZUFBZUMsS0FBS0MsU0FBUyxDQUFDSCxnQkFBZ0IsU0FBU0ksU0FBUzlOLEdBQUcsRUFBRStOLEtBQUs7Z0JBQzVFLElBQUl4TCxPQUFPMkssZUFBZWE7Z0JBQzFCLElBQUl4TCxTQUFTLFVBQVU7b0JBQ3JCLE9BQU9rRSxPQUFPc0g7Z0JBQ2hCO2dCQUNBLE9BQU9BO1lBQ1Q7WUFDQSxPQUFPLElBQUloQyxjQUFjLGFBQWFyRCxXQUFXLE9BQU8rRCxlQUFlLGlCQUFpQmhHLE9BQU9xRyxhQUFhLE9BQVEsbUJBQWtCbkUsZ0JBQWdCLHdCQUF3QmdGLGVBQWUsR0FBRTtRQUNqTTtRQUNBLE9BQU8xQiwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU2IsMEJBQTBCOEIsV0FBVztRQUM1QyxTQUFTakIsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUU3RCxhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVk7WUFDdEUsSUFBSSxPQUFPVSxnQkFBZ0IsWUFBWTtnQkFDckMsT0FBTyxJQUFJcEIsY0FBYyxlQUFlVSxlQUFlLHFCQUFxQjlELGdCQUFnQjtZQUM5RjtZQUNBLElBQUltRSxZQUFZUCxLQUFLLENBQUNDLFNBQVM7WUFDL0IsSUFBSU8sV0FBV0MsWUFBWUY7WUFDM0IsSUFBSUMsYUFBYSxVQUFVO2dCQUN6QixPQUFPLElBQUloQixjQUFjLGFBQWFyRCxXQUFXLE9BQU8rRCxlQUFlLGVBQWdCLE9BQU1NLFdBQVcsb0JBQW9CcEUsZ0JBQWdCLHdCQUF1QjtZQUNySztZQUNBLElBQUssSUFBSTNJLE9BQU84TSxVQUFXO2dCQUN6QixJQUFJbEYsSUFBSWtGLFdBQVc5TSxNQUFNO29CQUN2QixJQUFJcUksUUFBUThFLFlBQVlMLFdBQVc5TSxLQUFLMkksZUFBZUQsVUFBVStELGVBQWUsTUFBTXpNLEtBQUsySDtvQkFDM0YsSUFBSVUsaUJBQWlCQyxPQUFPO3dCQUMxQixPQUFPRDtvQkFDVDtnQkFDRjtZQUNGO1lBQ0EsT0FBTztRQUNUO1FBQ0EsT0FBTzRELDJCQUEyQkM7SUFDcEM7SUFFQSxTQUFTVCx1QkFBdUJ1QyxtQkFBbUI7UUFDakQsSUFBSSxDQUFDWixNQUFNQyxPQUFPLENBQUNXLHNCQUFzQjtZQW56QjdDLEtBb3pCK0IsR0FBZTdFLGVBQWUsNEVBQTRFLENBQU07WUFDekksT0FBT0M7UUFDVDtRQUVBLElBQUssSUFBSXhKLElBQUksR0FBR0EsSUFBSW9PLG9CQUFvQmxPLE1BQU0sRUFBRUYsSUFBSztZQUNuRCxJQUFJcU8sVUFBVUQsbUJBQW1CLENBQUNwTyxFQUFFO1lBQ3BDLElBQUksT0FBT3FPLFlBQVksWUFBWTtnQkFDakM5RSxlQUNFLHVGQUNBLGNBQWMrRSx5QkFBeUJELFdBQVcsZUFBZXJPLElBQUk7Z0JBRXZFLE9BQU93SjtZQUNUO1FBQ0Y7UUFFQSxTQUFTOEMsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUU3RCxhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVk7WUFDdEUsSUFBSTBCLGdCQUFnQixFQUFFO1lBQ3RCLElBQUssSUFBSXZPLElBQUksR0FBR0EsSUFBSW9PLG9CQUFvQmxPLE1BQU0sRUFBRUYsSUFBSztnQkFDbkQsSUFBSXFPLFVBQVVELG1CQUFtQixDQUFDcE8sRUFBRTtnQkFDcEMsSUFBSXdPLGdCQUFnQkgsUUFBUTFCLE9BQU9DLFVBQVU3RCxlQUFlRCxVQUFVK0QsY0FBYzlFO2dCQUNwRixJQUFJeUcsaUJBQWlCLE1BQU07b0JBQ3pCLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSUEsY0FBY3BDLElBQUksSUFBSXBFLElBQUl3RyxjQUFjcEMsSUFBSSxFQUFFLGlCQUFpQjtvQkFDakVtQyxjQUFjRSxJQUFJLENBQUNELGNBQWNwQyxJQUFJLENBQUNhLFlBQVk7Z0JBQ3BEO1lBQ0Y7WUFDQSxJQUFJeUIsdUJBQXVCLGNBQWV4TyxNQUFNLEdBQUcsSUFBSyw2QkFBNkJxTyxjQUFjcEgsSUFBSSxDQUFDLFFBQVEsTUFBSztZQUNySCxPQUFPLElBQUlnRixjQUFjLGFBQWFyRCxXQUFXLE9BQU8rRCxlQUFlLG1CQUFvQixPQUFNOUQsZ0JBQWdCLE1BQU0yRix1QkFBdUIsR0FBRTtRQUNsSjtRQUNBLE9BQU9yQywyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU2Y7UUFDUCxTQUFTZSxTQUFTSyxLQUFLLEVBQUVDLFFBQVEsRUFBRTdELGFBQWEsRUFBRUQsUUFBUSxFQUFFK0QsWUFBWTtZQUN0RSxJQUFJLENBQUM4QixPQUFPaEMsS0FBSyxDQUFDQyxTQUFTLEdBQUc7Z0JBQzVCLE9BQU8sSUFBSVQsY0FBYyxhQUFhckQsV0FBVyxPQUFPK0QsZUFBZSxtQkFBb0IsT0FBTTlELGdCQUFnQiwwQkFBeUI7WUFDNUk7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxPQUFPc0QsMkJBQTJCQztJQUNwQztJQUVBLFNBQVNzQyxzQkFBc0I3RixhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVksRUFBRXpNLEdBQUcsRUFBRXVDLElBQUk7UUFDN0UsT0FBTyxJQUFJd0osY0FDVCxDQUFDcEQsaUJBQWlCLGFBQVksSUFBSyxPQUFPRCxXQUFXLFlBQVkrRCxlQUFlLE1BQU16TSxNQUFNLG1CQUM1RixpRkFBaUZ1QyxPQUFPO0lBRTVGO0lBRUEsU0FBU29KLHVCQUF1QjhDLFVBQVU7UUFDeEMsU0FBU3ZDLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFN0QsYUFBYSxFQUFFRCxRQUFRLEVBQUUrRCxZQUFZO1lBQ3RFLElBQUlLLFlBQVlQLEtBQUssQ0FBQ0MsU0FBUztZQUMvQixJQUFJTyxXQUFXQyxZQUFZRjtZQUMzQixJQUFJQyxhQUFhLFVBQVU7Z0JBQ3pCLE9BQU8sSUFBSWhCLGNBQWMsYUFBYXJELFdBQVcsT0FBTytELGVBQWUsZ0JBQWdCTSxXQUFXLE9BQVEsbUJBQWtCcEUsZ0JBQWdCLHVCQUFzQjtZQUNwSztZQUNBLElBQUssSUFBSTNJLE9BQU95TyxXQUFZO2dCQUMxQixJQUFJUixVQUFVUSxVQUFVLENBQUN6TyxJQUFJO2dCQUM3QixJQUFJLE9BQU9pTyxZQUFZLFlBQVk7b0JBQ2pDLE9BQU9PLHNCQUFzQjdGLGVBQWVELFVBQVUrRCxjQUFjek0sS0FBS2tOLGVBQWVlO2dCQUMxRjtnQkFDQSxJQUFJNUYsUUFBUTRGLFFBQVFuQixXQUFXOU0sS0FBSzJJLGVBQWVELFVBQVUrRCxlQUFlLE1BQU16TSxLQUFLMkg7Z0JBQ3ZGLElBQUlVLE9BQU87b0JBQ1QsT0FBT0E7Z0JBQ1Q7WUFDRjtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU80RCwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU0wsNkJBQTZCNEMsVUFBVTtRQUM5QyxTQUFTdkMsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUU3RCxhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVk7WUFDdEUsSUFBSUssWUFBWVAsS0FBSyxDQUFDQyxTQUFTO1lBQy9CLElBQUlPLFdBQVdDLFlBQVlGO1lBQzNCLElBQUlDLGFBQWEsVUFBVTtnQkFDekIsT0FBTyxJQUFJaEIsY0FBYyxhQUFhckQsV0FBVyxPQUFPK0QsZUFBZSxnQkFBZ0JNLFdBQVcsT0FBUSxtQkFBa0JwRSxnQkFBZ0IsdUJBQXNCO1lBQ3BLO1lBQ0EsOEVBQThFO1lBQzlFLElBQUkrRixVQUFVckgsYUFBYSxDQUFDLEdBQUdrRixLQUFLLENBQUNDLFNBQVMsRUFBRWlDO1lBQ2hELElBQUssSUFBSXpPLE9BQU8wTyxRQUFTO2dCQUN2QixJQUFJVCxVQUFVUSxVQUFVLENBQUN6TyxJQUFJO2dCQUM3QixJQUFJNEgsSUFBSTZHLFlBQVl6TyxRQUFRLE9BQU9pTyxZQUFZLFlBQVk7b0JBQ3pELE9BQU9PLHNCQUFzQjdGLGVBQWVELFVBQVUrRCxjQUFjek0sS0FBS2tOLGVBQWVlO2dCQUMxRjtnQkFDQSxJQUFJLENBQUNBLFNBQVM7b0JBQ1osT0FBTyxJQUFJbEMsY0FDVCxhQUFhckQsV0FBVyxPQUFPK0QsZUFBZSxZQUFZek0sTUFBTSxvQkFBb0IySSxnQkFBZ0IsT0FDcEcsbUJBQW1CaUYsS0FBS0MsU0FBUyxDQUFDdEIsS0FBSyxDQUFDQyxTQUFTLEVBQUUsTUFBTSxRQUN6RCxtQkFBbUJvQixLQUFLQyxTQUFTLENBQUNwTyxPQUFPZSxJQUFJLENBQUNpTyxhQUFhLE1BQU07Z0JBRXJFO2dCQUNBLElBQUlwRyxRQUFRNEYsUUFBUW5CLFdBQVc5TSxLQUFLMkksZUFBZUQsVUFBVStELGVBQWUsTUFBTXpNLEtBQUsySDtnQkFDdkYsSUFBSVUsT0FBTztvQkFDVCxPQUFPQTtnQkFDVDtZQUNGO1lBQ0EsT0FBTztRQUNUO1FBRUEsT0FBTzRELDJCQUEyQkM7SUFDcEM7SUFFQSxTQUFTcUMsT0FBT3pCLFNBQVM7UUFDdkIsT0FBUSxPQUFPQTtZQUNiLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPLENBQUNBO1lBQ1YsS0FBSztnQkFDSCxJQUFJTSxNQUFNQyxPQUFPLENBQUNQLFlBQVk7b0JBQzVCLE9BQU9BLFVBQVU2QixLQUFLLENBQUNKO2dCQUN6QjtnQkFDQSxJQUFJekIsY0FBYyxRQUFReEQsZUFBZXdELFlBQVk7b0JBQ25ELE9BQU87Z0JBQ1Q7Z0JBRUEsSUFBSWpELGFBQWFGLGNBQWNtRDtnQkFDL0IsSUFBSWpELFlBQVk7b0JBQ2QsSUFBSUosV0FBV0ksV0FBVzFKLElBQUksQ0FBQzJNO29CQUMvQixJQUFJOEI7b0JBQ0osSUFBSS9FLGVBQWVpRCxVQUFVK0IsT0FBTyxFQUFFO3dCQUNwQyxNQUFPLENBQUMsQ0FBQ0QsT0FBT25GLFNBQVNxRixJQUFJLEVBQUMsRUFBR0MsSUFBSSxDQUFFOzRCQUNyQyxJQUFJLENBQUNSLE9BQU9LLEtBQUtiLEtBQUssR0FBRztnQ0FDdkIsT0FBTzs0QkFDVDt3QkFDRjtvQkFDRixPQUFPO3dCQUNMLCtEQUErRDt3QkFDL0QsTUFBTyxDQUFDLENBQUNhLE9BQU9uRixTQUFTcUYsSUFBSSxFQUFDLEVBQUdDLElBQUksQ0FBRTs0QkFDckMsSUFBSUMsUUFBUUosS0FBS2IsS0FBSzs0QkFDdEIsSUFBSWlCLE9BQU87Z0NBQ1QsSUFBSSxDQUFDVCxPQUFPUyxLQUFLLENBQUMsRUFBRSxHQUFHO29DQUNyQixPQUFPO2dDQUNUOzRCQUNGO3dCQUNGO29CQUNGO2dCQUNGLE9BQU87b0JBQ0wsT0FBTztnQkFDVDtnQkFFQSxPQUFPO1lBQ1Q7Z0JBQ0UsT0FBTztRQUNYO0lBQ0Y7SUFFQSxTQUFTQyxTQUFTbEMsUUFBUSxFQUFFRCxTQUFTO1FBQ25DLGlCQUFpQjtRQUNqQixJQUFJQyxhQUFhLFVBQVU7WUFDekIsT0FBTztRQUNUO1FBRUEsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQ0QsV0FBVztZQUNkLE9BQU87UUFDVDtRQUVBLHdEQUF3RDtRQUN4RCxJQUFJQSxTQUFTLENBQUMsZ0JBQWdCLEtBQUssVUFBVTtZQUMzQyxPQUFPO1FBQ1Q7UUFFQSxnRUFBZ0U7UUFDaEUsSUFBSSxPQUFPL0wsV0FBVyxjQUFjK0wscUJBQXFCL0wsUUFBUTtZQUMvRCxPQUFPO1FBQ1Q7UUFFQSxPQUFPO0lBQ1Q7SUFFQSx5RUFBeUU7SUFDekUsU0FBU2lNLFlBQVlGLFNBQVM7UUFDNUIsSUFBSUMsV0FBVyxPQUFPRDtRQUN0QixJQUFJTSxNQUFNQyxPQUFPLENBQUNQLFlBQVk7WUFDNUIsT0FBTztRQUNUO1FBQ0EsSUFBSUEscUJBQXFCb0MsUUFBUTtZQUMvQix5RUFBeUU7WUFDekUsd0VBQXdFO1lBQ3hFLDJCQUEyQjtZQUMzQixPQUFPO1FBQ1Q7UUFDQSxJQUFJRCxTQUFTbEMsVUFBVUQsWUFBWTtZQUNqQyxPQUFPO1FBQ1Q7UUFDQSxPQUFPQztJQUNUO0lBRUEsNEVBQTRFO0lBQzVFLG9DQUFvQztJQUNwQyxTQUFTRyxlQUFlSixTQUFTO1FBQy9CLElBQUksT0FBT0EsY0FBYyxlQUFlQSxjQUFjLE1BQU07WUFDMUQsT0FBTyxLQUFLQTtRQUNkO1FBQ0EsSUFBSUMsV0FBV0MsWUFBWUY7UUFDM0IsSUFBSUMsYUFBYSxVQUFVO1lBQ3pCLElBQUlELHFCQUFxQnFDLE1BQU07Z0JBQzdCLE9BQU87WUFDVCxPQUFPLElBQUlyQyxxQkFBcUJvQyxRQUFRO2dCQUN0QyxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU9uQztJQUNUO0lBRUEseUVBQXlFO0lBQ3pFLDhDQUE4QztJQUM5QyxTQUFTbUIseUJBQXlCSCxLQUFLO1FBQ3JDLElBQUl4TCxPQUFPMkssZUFBZWE7UUFDMUIsT0FBUXhMO1lBQ04sS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTyxRQUFRQTtZQUNqQixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTyxPQUFPQTtZQUNoQjtnQkFDRSxPQUFPQTtRQUNYO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsU0FBU2tMLGFBQWFYLFNBQVM7UUFDN0IsSUFBSSxDQUFDQSxVQUFVc0MsV0FBVyxJQUFJLENBQUN0QyxVQUFVc0MsV0FBVyxDQUFDdEcsSUFBSSxFQUFFO1lBQ3pELE9BQU9nQjtRQUNUO1FBQ0EsT0FBT2dELFVBQVVzQyxXQUFXLENBQUN0RyxJQUFJO0lBQ25DO0lBRUFpQixlQUFleEIsY0FBYyxHQUFHVztJQUNoQ2EsZUFBZWQsaUJBQWlCLEdBQUdDLGlCQUFpQkQsaUJBQWlCO0lBQ3JFYyxlQUFlc0YsU0FBUyxHQUFHdEY7SUFFM0IsT0FBT0E7QUFDVDtBQUVBLFNBQVN1RixpQkFBaUI7QUFDMUIsU0FBU0MsMEJBQTBCO0FBQ25DQSx1QkFBdUJ0RyxpQkFBaUIsR0FBR3FHO0FBRTNDLElBQUlFLDJCQUEyQjtJQUM3QixTQUFTQyxLQUFLbEQsS0FBSyxFQUFFQyxRQUFRLEVBQUU3RCxhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVksRUFBRUMsTUFBTTtRQUMxRSxJQUFJQSxXQUFXL0Usd0JBQXdCO1lBQ3JDLDJDQUEyQztZQUMzQztRQUNGO1FBQ0EsSUFBSVAsTUFBTSxJQUFJa0IsTUFDWix5RkFDQSxrREFDQTtRQUVGbEIsSUFBSTBCLElBQUksR0FBRztRQUNYLE1BQU0xQjtJQUNSO0lBQUdxSSxLQUFLbkQsVUFBVSxHQUFHbUQ7SUFDckIsU0FBU0M7UUFDUCxPQUFPRDtJQUNULEVBQUcsYUFBYTtJQUNoQixvRkFBb0Y7SUFDcEYsSUFBSTFGLGlCQUFpQjtRQUNuQkMsT0FBT3lGO1FBQ1B2RixRQUFRdUY7UUFDUnRGLE1BQU1zRjtRQUNOckYsTUFBTXFGO1FBQ05wRixRQUFRb0Y7UUFDUjlKLFFBQVE4SjtRQUNSbkYsUUFBUW1GO1FBQ1JsRixRQUFRa0Y7UUFFUmpGLEtBQUtpRjtRQUNML0UsU0FBU2dGO1FBQ1Q5RSxTQUFTNkU7UUFDVDNFLGFBQWEyRTtRQUNiekUsWUFBWTBFO1FBQ1p4RSxNQUFNdUU7UUFDTnJFLFVBQVVzRTtRQUNWcEUsT0FBT29FO1FBQ1BsRSxXQUFXa0U7UUFDWGhFLE9BQU9nRTtRQUNQOUQsT0FBTzhEO1FBRVBuSCxnQkFBZ0JnSDtRQUNoQnRHLG1CQUFtQnFHO0lBQ3JCO0lBRUF2RixlQUFlc0YsU0FBUyxHQUFHdEY7SUFFM0IsT0FBT0E7QUFDVDtBQUVBLElBQUk0RixZQUFZalAscUJBQXFCLFNBQVVFLE1BQU07SUFDckQ7Ozs7O0NBS0MsR0FFRCxJQUFJMkQsSUFBeUIsRUFBYztRQUN6QyxJQUFJcUwsVUFBVTVKO1FBRWQsaUZBQWlGO1FBQ2pGLGtDQUFrQztRQUNsQyxJQUFJdUQsc0JBQXNCO1FBQzFCM0ksT0FBT0MsT0FBTyxHQUFHd0ksd0JBQXdCdUcsUUFBUWxNLFNBQVMsRUFBRTZGO0lBQzlELE9BQU8sRUFJTjtBQUNEO0FBRUEsSUFBSXNHLGNBQWM7SUFDaEJDLGVBQWVILFVBQVVoSyxNQUFNO0lBQy9Cb0ssTUFBTUosVUFBVXJGLE1BQU07SUFDdEIwRixNQUFNTCxVQUFVeEYsSUFBSTtJQUNwQjhGLE1BQU1OLFVBQVV0RixNQUFNO0lBQ3RCNkYsT0FBT1AsVUFBVXRGLE1BQU07SUFDdkI4RixXQUFXUixVQUFVdEYsTUFBTTtJQUMzQitGLE1BQU1ULFVBQVVuRSxTQUFTLENBQUM7UUFBQ21FLFVBQVV0RixNQUFNO1FBQUVzRixVQUFVeEYsSUFBSTtLQUFDO0lBQzVEa0csY0FBY1YsVUFBVXhGLElBQUk7SUFDNUJtRyxVQUFVWCxVQUFVbkUsU0FBUyxDQUFDO1FBQUNtRSxVQUFVakYsT0FBTyxDQUFDaUYsVUFBVXRGLE1BQU07UUFBR3NGLFVBQVV4RixJQUFJO0tBQUM7SUFDbkZvRyxrQkFBa0JaLFVBQVVoSyxNQUFNO0lBQ2xDNkssVUFBVWIsVUFBVXJGLE1BQU07SUFDMUJtRyxjQUFjZCxVQUFVdkYsSUFBSTtJQUM1QnNHLFlBQVlmLFVBQVV2RixJQUFJO0lBQzFCdUcsZ0JBQWdCaEIsVUFBVXZGLElBQUk7SUFDOUJ3RyxjQUFjakIsVUFBVXZGLElBQUk7SUFDNUJ5RyxnQkFBZ0JsQixVQUFVdkYsSUFBSTtBQUNoQztBQUVBLElBQUkwRyxjQUFjLENBQUM7QUFFbkIsSUFBSUMsT0FBTyxTQUFTQSxRQUFRO0FBRTVCLElBQUlDLG1CQUFtQixTQUFTQSxpQkFBaUJDLElBQUk7SUFDbkQsSUFBSUMsZ0JBQWdCRCxLQUFLQyxhQUFhO0lBQ3RDLElBQUlDLHVCQUFTblMsMkNBQUlBLGVBQUNDLGlEQUFVQSxDQUFDLFNBQVVtUyxNQUFNLEVBQUVDLFlBQVk7UUFDekQsSUFBSUMsd0JBQXdCRixPQUFPdEIsYUFBYSxFQUM1Q0EsZ0JBQWdCd0IsMEJBQTBCLEtBQUssSUFBSSxPQUFPQSx1QkFDMURDLGVBQWVILE9BQU9yQixJQUFJLEVBQzFCQSxPQUFPd0IsaUJBQWlCLEtBQUssSUFBSSxPQUFPQSxjQUN4Q0MsZUFBZUosT0FBT3BCLElBQUksRUFDMUJBLE9BQU93QixpQkFBaUIsS0FBSyxJQUFJLE9BQU9BLGNBQ3hDQyxnQkFBZ0JMLE9BQU9sQixLQUFLLEVBQzVCQSxRQUFRdUIsa0JBQWtCLEtBQUssSUFBSSxJQUFJQSxlQUN2Q0Msb0JBQW9CTixPQUFPakIsU0FBUyxFQUNwQ0EsWUFBWXVCLHNCQUFzQixLQUFLLElBQUksSUFBSUEsbUJBQy9DQyxtQkFBbUJQLE9BQU9kLFFBQVEsRUFDbENzQixhQUFhRCxxQkFBcUIsS0FBSyxJQUFJLE9BQU9BLGtCQUNsREUsZUFBZVQsT0FBT25CLElBQUksRUFDMUJBLE9BQU80QixpQkFBaUIsS0FBSyxJQUFJLE9BQU9BLGNBQ3hDQyx1QkFBdUJWLE9BQU9mLFlBQVksRUFDMUNBLGVBQWV5Qix5QkFBeUIsS0FBSyxJQUFJLE9BQU9BLHNCQUN4REMsbUJBQW1CWCxPQUFPWixRQUFRLEVBQ2xDQSxXQUFXdUIscUJBQXFCLEtBQUssSUFBSSxRQUFRQSxrQkFDakRDLGVBQWVaLE9BQU9oQixJQUFJLEVBQzFCQSxPQUFPNEIsaUJBQWlCLEtBQUssSUFBSSxPQUFPQSxjQUN4Q0Msd0JBQXdCYixPQUFPYixnQkFBZ0IsRUFDL0MyQixxQkFBcUJELDBCQUEwQixLQUFLLElBQUluQixjQUFjbUIsdUJBQ3RFRSx1QkFBdUJmLE9BQU9YLFlBQVksRUFDMUNBLGVBQWUwQix5QkFBeUIsS0FBSyxJQUFJLE9BQU9BLHNCQUN4REMsaUJBQWlCaEIsT0FBT2lCLE1BQU0sRUFDOUJBLFNBQVNELG1CQUFtQixLQUFLLElBQUlyQixPQUFPcUIsZ0JBQzVDRSxxQkFBcUJsQixPQUFPVixVQUFVLEVBQ3RDQSxhQUFhNEIsdUJBQXVCLEtBQUssSUFBSXZCLE9BQU91QixvQkFDcERDLHdCQUF3Qm5CLE9BQU9ULGNBQWMsRUFDN0NBLGlCQUFpQjRCLDBCQUEwQixLQUFLLElBQUl4QixPQUFPd0IsdUJBQzNEQyx1QkFBdUJwQixPQUFPUixZQUFZLEVBQzFDQSxlQUFlNEIseUJBQXlCLEtBQUssSUFBSXpCLE9BQU95QixzQkFDeERDLHdCQUF3QnJCLE9BQU9QLGNBQWMsRUFDN0NBLGlCQUFpQjRCLDBCQUEwQixLQUFLLElBQUkxQixPQUFPMEIsdUJBQzNEbEcsUUFBUWxNLDhCQUE4QitRLFFBQVE7WUFBQztZQUFpQjtZQUFRO1lBQVE7WUFBUztZQUFhO1lBQVk7WUFBUTtZQUFnQjtZQUFZO1lBQVE7WUFBb0I7WUFBZ0I7WUFBVTtZQUFjO1lBQWtCO1lBQWdCO1NBQWlCO1FBRWpSLElBQUlzQixpQkFBaUJ4VCw2Q0FBTUE7UUFDM0IsSUFBSXlULFVBQVV6VCw2Q0FBTUE7UUFFcEIsSUFBSTBULFlBQVl6VCwrQ0FBUUEsQ0FBQyxRQUNyQjBULFFBQVFELFNBQVMsQ0FBQyxFQUFFLEVBQ3BCRSxXQUFXRixTQUFTLENBQUMsRUFBRTtRQUUzQixJQUFJRyxhQUFhNVQsK0NBQVFBLENBQUN5UyxhQUN0QnRCLFdBQVd5QyxVQUFVLENBQUMsRUFBRSxFQUN4QkMsY0FBY0QsVUFBVSxDQUFDLEVBQUU7UUFFL0IzVCxnREFBU0EsQ0FBQztZQUNSLElBQUksQ0FBQ0UsZ0VBQUtBLENBQUNnUixVQUFVc0IsYUFBYW9CLFlBQVlwQjtRQUNoRCxHQUFHO1lBQUNBO1lBQVl0QjtTQUFTO1FBRXpCLElBQUkyQyxhQUFhOVQsK0NBQVFBLENBQUMrUyxxQkFDdEIzQixtQkFBbUIwQyxVQUFVLENBQUMsRUFBRSxFQUNoQ0Msc0JBQXNCRCxVQUFVLENBQUMsRUFBRTtRQUV2QzdULGdEQUFTQSxDQUFDO1lBQ1IsSUFBSSxDQUFDRSxnRUFBS0EsQ0FBQ2lSLGtCQUFrQjJCLHFCQUFxQmdCLG9CQUFvQmhCO1FBQ3hFLEdBQUc7WUFBQ0E7WUFBb0IzQjtTQUFpQjtRQUN6Q25SLGdEQUFTQSxDQUFDO1lBQ1IsT0FBTztnQkFDTCxPQUFPdVQsUUFBUVEsT0FBTyxDQUFDQyxtQkFBbUIsQ0FBQyxZQUFZMUM7WUFDekQ7UUFDRixHQUFHO1lBQUNBO1NBQVc7UUFDZnRSLGdEQUFTQSxDQUFDO1lBQ1IsT0FBTztnQkFDTCxPQUFPdVQsUUFBUVEsT0FBTyxDQUFDQyxtQkFBbUIsQ0FBQyxnQkFBZ0J6QztZQUM3RDtRQUNGLEdBQUc7WUFBQ0E7U0FBZTtRQUNuQnZSLGdEQUFTQSxDQUFDO1lBQ1IsT0FBTztnQkFDTCxPQUFPdVQsUUFBUVEsT0FBTyxDQUFDQyxtQkFBbUIsQ0FBQyxjQUFjeEM7WUFDM0Q7UUFDRixHQUFHO1lBQUNBO1NBQWE7UUFDakJ4UixnREFBU0EsQ0FBQztZQUNSLE9BQU87Z0JBQ0wsT0FBT3VULFFBQVFRLE9BQU8sQ0FBQ0MsbUJBQW1CLENBQUMsZ0JBQWdCdkM7WUFDN0Q7UUFDRixHQUFHO1lBQUNBO1NBQWU7UUFDbkJ6UixnREFBU0EsQ0FBQztZQUNSLE9BQU87Z0JBQ0wsT0FBT3VULFFBQVFRLE9BQU8sQ0FBQ0MsbUJBQW1CLENBQUMsYUFBYWY7WUFDMUQ7UUFDRixHQUFHO1lBQUNBO1NBQU87UUFDWCxJQUFJZ0IsZ0JBQWdCaFUsa0RBQVdBLENBQUMsU0FBVWlVLE1BQU07WUFDOUNYLFFBQVFRLE9BQU8sR0FBR0c7WUFDbEIsSUFBSWpDLGNBQWNBLGFBQWE4QixPQUFPLEdBQUdHO1FBQzNDLEdBQUcsRUFBRTtRQUNMbFUsZ0RBQVNBLENBQUM7WUFDUixTQUFTbVU7Z0JBQ1AsSUFBSXpELGlCQUFpQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVLE9BQU9BO2dCQUV2RSxJQUFJLE9BQU9BLGFBQWEsQ0FBQyxVQUFVLEtBQUssVUFBVTtvQkFDaEQsT0FBT3ZRLG1EQUFLQSxDQUFDdVEsYUFBYSxDQUFDLFVBQVU7Z0JBQ3ZDO2dCQUVBLE9BQU92USxtREFBS0EsQ0FBQ3VRO1lBQ2Y7WUFFQSxJQUFJaFIsU0FBU29TLGNBQWM7Z0JBQ3pCcEIsZUFBZXlEO2dCQUNmeEQsTUFBTUE7Z0JBQ055RCxXQUFXZCxlQUFlUyxPQUFPO2dCQUNqQzNDLFVBQVVBO2dCQUNWSixNQUFNO2dCQUNOcUQsVUFBVTtnQkFDVmxELGtCQUFrQkE7Z0JBQ2xCRSxjQUFjQTtZQUNoQjtZQUNBNEMsY0FBY3ZVO1lBRWQsSUFBSTRVLGNBQWMsU0FBU0E7Z0JBQ3pCLE9BQU9aLFNBQVM7WUFDbEI7WUFFQUgsUUFBUVEsT0FBTyxDQUFDUSxnQkFBZ0IsQ0FBQyxhQUFhRDtZQUM5QyxPQUFPO2dCQUNMZixRQUFRUSxPQUFPLENBQUNDLG1CQUFtQixDQUFDLGFBQWFNO2dCQUNqRFosU0FBUztnQkFDVEgsUUFBUVEsT0FBTyxDQUFDUyxPQUFPO2dCQUN2QlAsY0FBY3hOO1lBQ2hCO1FBQ0YsR0FBRztZQUFDdUs7WUFBTUk7WUFBVUQ7WUFBa0JUO1lBQWVDO1lBQU1VO1lBQWM0QztTQUFjO1FBQ3ZGalUsZ0RBQVNBLENBQUM7WUFDUnVULFFBQVFRLE9BQU8sQ0FBQ1EsZ0JBQWdCLENBQUMsYUFBYXRCO1FBQ2hELEdBQUc7WUFBQ0E7U0FBTztRQUNYalQsZ0RBQVNBLENBQUM7WUFDUnVULFFBQVFRLE9BQU8sQ0FBQ1EsZ0JBQWdCLENBQUMsWUFBWWpEO1FBQy9DLEdBQUc7WUFBQ0E7U0FBVztRQUNmdFIsZ0RBQVNBLENBQUM7WUFDUnVULFFBQVFRLE9BQU8sQ0FBQ1EsZ0JBQWdCLENBQUMsZ0JBQWdCaEQ7UUFDbkQsR0FBRztZQUFDQTtTQUFlO1FBQ25CdlIsZ0RBQVNBLENBQUM7WUFDUnVULFFBQVFRLE9BQU8sQ0FBQ1EsZ0JBQWdCLENBQUMsY0FBYy9DO1FBQ2pELEdBQUc7WUFBQ0E7U0FBYTtRQUNqQnhSLGdEQUFTQSxDQUFDO1lBQ1J1VCxRQUFRUSxPQUFPLENBQUNRLGdCQUFnQixDQUFDLGdCQUFnQjlDO1FBQ25ELEdBQUc7WUFBQ0E7U0FBZTtRQUNuQnpSLGdEQUFTQSxDQUFDO1lBQ1IsSUFBSSxDQUFDeVQsT0FBTztZQUNaRixRQUFRUSxPQUFPLENBQUMvQyxJQUFJLEdBQUdBO1FBQ3pCLEdBQUc7WUFBQ3lDO1lBQU96QztTQUFLO1FBQ2hCLElBQUl5RCx3QkFBd0IzVSw2Q0FBTUEsQ0FBQztRQUNuQ0UsZ0RBQVNBLENBQUM7WUFDUixJQUFJLENBQUN5VCxPQUFPO1lBRVosU0FBU2lCLFlBQVlDLFNBQVM7Z0JBQzVCcEIsUUFBUVEsT0FBTyxDQUFDYSxXQUFXLENBQUNELFdBQVc7Z0JBQ3ZDcEIsUUFBUVEsT0FBTyxDQUFDYyxZQUFZLENBQUM5RDtZQUMvQjtZQUVBLElBQUlILFNBQVMsTUFBTTtnQkFDakIsSUFBSWtFLFFBQVE7Z0JBRVosSUFBSTVELFVBQVU7b0JBQ1pxQyxRQUFRUSxPQUFPLENBQUNnQixZQUFZLENBQUM3RCxVQUFVNEQ7b0JBQ3ZDTCxzQkFBc0JWLE9BQU8sR0FBRztvQkFFaEMsSUFBSWhELGNBQWMsQ0FBQyxHQUFHO3dCQUNwQixJQUFJNEQsWUFBWXpELFFBQVEsQ0FBQyxFQUFFO3dCQUMzQndELFlBQVlDO29CQUNkO2dCQUNGLE9BQU87b0JBQ0wsSUFBSUYsc0JBQXNCVixPQUFPLEVBQUVSLFFBQVFRLE9BQU8sQ0FBQ2lCLGFBQWEsQ0FBQ0Y7b0JBQ2pFTCxzQkFBc0JWLE9BQU8sR0FBRztvQkFFaEMsSUFBSWhELGNBQWMsQ0FBQyxHQUFHO3dCQUNwQixJQUFJa0UsYUFBYTFCLFFBQVFRLE9BQU8sQ0FBQ21CLFdBQVcsQ0FBQzt3QkFFN0NSLFlBQVlPO29CQUNkLE9BQU87d0JBQ0wxQixRQUFRUSxPQUFPLENBQUNuRCxJQUFJO29CQUN0QjtnQkFDRjtZQUNGLE9BQU8sSUFBSUEsU0FBUyxPQUFPO2dCQUN6QjJDLFFBQVFRLE9BQU8sQ0FBQ29CLEtBQUs7WUFDdkI7UUFDRixHQUFHO1lBQUN2RTtZQUFNTTtZQUFVdUM7WUFBTzFDO1NBQVU7UUFDckMvUSxnREFBU0EsQ0FBQztZQUNSLElBQUksQ0FBQ3lULE9BQU87WUFDWixJQUFJMkIsT0FBT0MsS0FBSyxDQUFDdkUsUUFBUTtZQUN6QnlDLFFBQVFRLE9BQU8sQ0FBQ3VCLFFBQVEsQ0FBQ3hFO1FBQzNCLEdBQUc7WUFBQ0E7WUFBTzJDO1NBQU07UUFDakJ6VCxnREFBU0EsQ0FBQztZQUNSLElBQUksQ0FBQ3lULE9BQU87WUFDWkYsUUFBUVEsT0FBTyxDQUFDYyxZQUFZLENBQUM5RDtRQUMvQixHQUFHO1lBQUNBO1lBQVcwQztTQUFNO1FBQ3JCelQsZ0RBQVNBLENBQUM7WUFDUixJQUFJLENBQUN5VCxPQUFPO1lBQ1osSUFBSTVDLFFBQVEsTUFBTTtZQUNsQixJQUFJMEUsVUFBVTtZQUNkLElBQUkzRSxNQUFNMkMsUUFBUVEsT0FBTyxDQUFDYSxXQUFXLENBQUMvRCxNQUFNMEU7aUJBQWNoQyxRQUFRUSxPQUFPLENBQUN5QixXQUFXLENBQUMzRSxNQUFNMEU7UUFDOUYsR0FBRztZQUFDMUU7WUFBTUQ7WUFBTTZDO1NBQU07UUFDdEJ6VCxnREFBU0EsQ0FBQztZQUNSLElBQUl1VCxRQUFRUSxPQUFPLENBQUMwQixXQUFXLEVBQUVsQyxRQUFRUSxPQUFPLENBQUMwQixXQUFXLENBQUN4RTtRQUMvRCxHQUFHO1lBQUNBO1NBQWE7UUFDakIsT0FBTyxXQUFXLEdBQUV0UiwwREFBbUIsQ0FBQyxPQUFPUyxTQUFTLENBQUMsR0FBRytNLE9BQU87WUFDakV3SSxLQUFLckM7UUFDUDtJQUNGO0lBQ0F2QixPQUFPeEIsU0FBUyxHQUFHRTtJQUNuQixPQUFPc0I7QUFDVDtBQUVBLElBQUk2RCxlQUFlaEUsaUJBQWlCbFMsbURBQU1BO0FBRTFDLGlFQUFla1csWUFBWUEsRUFBQyxDQUM1QiwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vb29vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWxvdHRpZS1wbGF5ZXIvZGlzdC9Mb3R0aWVQbGF5ZXIubW9kZXJuLmpzPzk2YmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvdHRpZSBmcm9tICdsb3R0aWUtd2ViJztcbmltcG9ydCBSZWFjdCwgeyBtZW1vLCBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGVxdWFsIGZyb20gJ2Zhc3QtZGVlcC1lcXVhbC9lczYvcmVhY3QnO1xuaW1wb3J0IGNsb25lIGZyb20gJ3JmZGMvZGVmYXVsdCc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxuLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgYj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yLGM9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyxkPWI/U3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixlPWI/U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LGY9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik6NjAxMDgsZz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTo2MDExNCxoPWI/U3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpOjYwMTA5LGs9Yj9TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTo2MDExMCxsPWI/U3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIik6NjAxMTEsbT1iP1N5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIik6NjAxMTEsbj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTo2MDExMixwPWI/U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpOjYwMTEzLHE9Yj9cblN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpOjYwMTIwLHI9Yj9TeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTo2MDExNSx0PWI/U3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik6NjAxMTYsdj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKTo2MDEyMSx3PWI/U3ltYm9sLmZvcihcInJlYWN0LmZ1bmRhbWVudGFsXCIpOjYwMTE3LHg9Yj9TeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpOjYwMTE4LHk9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik6NjAxMTk7XG5mdW5jdGlvbiB6KGEpe2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEpe3ZhciB1PWEuJCR0eXBlb2Y7c3dpdGNoKHUpe2Nhc2UgYzpzd2l0Y2goYT1hLnR5cGUsYSl7Y2FzZSBsOmNhc2UgbTpjYXNlIGU6Y2FzZSBnOmNhc2UgZjpjYXNlIHA6cmV0dXJuIGE7ZGVmYXVsdDpzd2l0Y2goYT1hJiZhLiQkdHlwZW9mLGEpe2Nhc2UgazpjYXNlIG46Y2FzZSB0OmNhc2UgcjpjYXNlIGg6cmV0dXJuIGE7ZGVmYXVsdDpyZXR1cm4gdX19Y2FzZSBkOnJldHVybiB1fX19ZnVuY3Rpb24gQShhKXtyZXR1cm4geihhKT09PW19dmFyIEFzeW5jTW9kZT1sO3ZhciBDb25jdXJyZW50TW9kZT1tO3ZhciBDb250ZXh0Q29uc3VtZXI9azt2YXIgQ29udGV4dFByb3ZpZGVyPWg7dmFyIEVsZW1lbnQ9Yzt2YXIgRm9yd2FyZFJlZj1uO3ZhciBGcmFnbWVudD1lO3ZhciBMYXp5PXQ7dmFyIE1lbW89cjt2YXIgUG9ydGFsPWQ7XG52YXIgUHJvZmlsZXI9Zzt2YXIgU3RyaWN0TW9kZT1mO3ZhciBTdXNwZW5zZT1wO3ZhciBpc0FzeW5jTW9kZT1mdW5jdGlvbihhKXtyZXR1cm4gQShhKXx8eihhKT09PWx9O3ZhciBpc0NvbmN1cnJlbnRNb2RlPUE7dmFyIGlzQ29udGV4dENvbnN1bWVyPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09a307dmFyIGlzQ29udGV4dFByb3ZpZGVyPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09aH07dmFyIGlzRWxlbWVudD1mdW5jdGlvbihhKXtyZXR1cm4gXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmYS4kJHR5cGVvZj09PWN9O3ZhciBpc0ZvcndhcmRSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1ufTt2YXIgaXNGcmFnbWVudD1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWV9O3ZhciBpc0xhenk9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT10fTtcbnZhciBpc01lbW89ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1yfTt2YXIgaXNQb3J0YWw9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1kfTt2YXIgaXNQcm9maWxlcj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWd9O3ZhciBpc1N0cmljdE1vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1mfTt2YXIgaXNTdXNwZW5zZT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXB9O1xudmFyIGlzVmFsaWRFbGVtZW50VHlwZT1mdW5jdGlvbihhKXtyZXR1cm4gXCJzdHJpbmdcIj09PXR5cGVvZiBhfHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgYXx8YT09PWV8fGE9PT1tfHxhPT09Z3x8YT09PWZ8fGE9PT1wfHxhPT09cXx8XCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmKGEuJCR0eXBlb2Y9PT10fHxhLiQkdHlwZW9mPT09cnx8YS4kJHR5cGVvZj09PWh8fGEuJCR0eXBlb2Y9PT1rfHxhLiQkdHlwZW9mPT09bnx8YS4kJHR5cGVvZj09PXd8fGEuJCR0eXBlb2Y9PT14fHxhLiQkdHlwZW9mPT09eXx8YS4kJHR5cGVvZj09PXYpfTt2YXIgdHlwZU9mPXo7XG5cbnZhciByZWFjdElzX3Byb2R1Y3Rpb25fbWluID0ge1xuXHRBc3luY01vZGU6IEFzeW5jTW9kZSxcblx0Q29uY3VycmVudE1vZGU6IENvbmN1cnJlbnRNb2RlLFxuXHRDb250ZXh0Q29uc3VtZXI6IENvbnRleHRDb25zdW1lcixcblx0Q29udGV4dFByb3ZpZGVyOiBDb250ZXh0UHJvdmlkZXIsXG5cdEVsZW1lbnQ6IEVsZW1lbnQsXG5cdEZvcndhcmRSZWY6IEZvcndhcmRSZWYsXG5cdEZyYWdtZW50OiBGcmFnbWVudCxcblx0TGF6eTogTGF6eSxcblx0TWVtbzogTWVtbyxcblx0UG9ydGFsOiBQb3J0YWwsXG5cdFByb2ZpbGVyOiBQcm9maWxlcixcblx0U3RyaWN0TW9kZTogU3RyaWN0TW9kZSxcblx0U3VzcGVuc2U6IFN1c3BlbnNlLFxuXHRpc0FzeW5jTW9kZTogaXNBc3luY01vZGUsXG5cdGlzQ29uY3VycmVudE1vZGU6IGlzQ29uY3VycmVudE1vZGUsXG5cdGlzQ29udGV4dENvbnN1bWVyOiBpc0NvbnRleHRDb25zdW1lcixcblx0aXNDb250ZXh0UHJvdmlkZXI6IGlzQ29udGV4dFByb3ZpZGVyLFxuXHRpc0VsZW1lbnQ6IGlzRWxlbWVudCxcblx0aXNGb3J3YXJkUmVmOiBpc0ZvcndhcmRSZWYsXG5cdGlzRnJhZ21lbnQ6IGlzRnJhZ21lbnQsXG5cdGlzTGF6eTogaXNMYXp5LFxuXHRpc01lbW86IGlzTWVtbyxcblx0aXNQb3J0YWw6IGlzUG9ydGFsLFxuXHRpc1Byb2ZpbGVyOiBpc1Byb2ZpbGVyLFxuXHRpc1N0cmljdE1vZGU6IGlzU3RyaWN0TW9kZSxcblx0aXNTdXNwZW5zZTogaXNTdXNwZW5zZSxcblx0aXNWYWxpZEVsZW1lbnRUeXBlOiBpc1ZhbGlkRWxlbWVudFR5cGUsXG5cdHR5cGVPZjogdHlwZU9mXG59O1xuXG52YXIgcmVhY3RJc19kZXZlbG9wbWVudCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG59KTtcblxudmFyIHJlYWN0SXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVhY3RJc19wcm9kdWN0aW9uX21pbjtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVhY3RJc19kZXZlbG9wbWVudDtcbn1cbn0pO1xuXG4vKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbnZhciBvYmplY3RBc3NpZ24gPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldF8xID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQkMSA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0XzE7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyQxID0gaGFzO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7IC8qKi8gfVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXMkMSh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICtcbiAgICAgICAgICAgICAgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0JDEpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB9XG59O1xuXG52YXIgY2hlY2tQcm9wVHlwZXNfMSA9IGNoZWNrUHJvcFR5cGVzO1xuXG52YXIgcHJpbnRXYXJuaW5nJDEgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmckMSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldF8xKSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyQxKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJyksXG4gICAgICAgICAge2V4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldF8xKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghcmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyQxKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZyQxKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZyQxKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmckMShcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICB2YXIgY2hlY2tlclJlc3VsdCA9IGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldF8xKTtcbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0LmRhdGEgJiYgaGFzKGNoZWNrZXJSZXN1bHQuZGF0YSwgJ2V4cGVjdGVkVHlwZScpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AnICsgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZSArICdgLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbSBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gb2JqZWN0QXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmIChoYXMoc2hhcGVUeXBlcywga2V5KSAmJiB0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldF8xKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlc18xO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzXzEucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbldpdGhSZXNldCgpIHt9XG5lbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LnJlc2V0V2FybmluZ0NhY2hlID0gZW1wdHlGdW5jdGlvbjtcblxudmFyIGZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB0aHJvdyBlcnI7XG4gIH0gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH0gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBiaWdpbnQ6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgZWxlbWVudFR5cGU6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbSxcblxuICAgIGNoZWNrUHJvcFR5cGVzOiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LFxuICAgIHJlc2V0V2FybmluZ0NhY2hlOiBlbXB0eUZ1bmN0aW9uXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxudmFyIHByb3BUeXBlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZWFjdElzO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5V2l0aFR5cGVDaGVja2VycyhSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zKCk7XG59XG59KTtcblxudmFyIHByb3BUeXBlcyQxID0ge1xuICBhbmltYXRpb25EYXRhOiBwcm9wVHlwZXMub2JqZWN0LFxuICBwYXRoOiBwcm9wVHlwZXMuc3RyaW5nLFxuICBwbGF5OiBwcm9wVHlwZXMuYm9vbCxcbiAgZ29UbzogcHJvcFR5cGVzLm51bWJlcixcbiAgc3BlZWQ6IHByb3BUeXBlcy5udW1iZXIsXG4gIGRpcmVjdGlvbjogcHJvcFR5cGVzLm51bWJlcixcbiAgbG9vcDogcHJvcFR5cGVzLm9uZU9mVHlwZShbcHJvcFR5cGVzLm51bWJlciwgcHJvcFR5cGVzLmJvb2xdKSxcbiAgdXNlU3ViZnJhbWVzOiBwcm9wVHlwZXMuYm9vbCxcbiAgc2VnbWVudHM6IHByb3BUeXBlcy5vbmVPZlR5cGUoW3Byb3BUeXBlcy5hcnJheU9mKHByb3BUeXBlcy5udW1iZXIpLCBwcm9wVHlwZXMuYm9vbF0pLFxuICByZW5kZXJlclNldHRpbmdzOiBwcm9wVHlwZXMub2JqZWN0LFxuICByZW5kZXJlcjogcHJvcFR5cGVzLnN0cmluZyxcbiAgYXVkaW9GYWN0b3J5OiBwcm9wVHlwZXMuZnVuYyxcbiAgb25Db21wbGV0ZTogcHJvcFR5cGVzLmZ1bmMsXG4gIG9uTG9vcENvbXBsZXRlOiBwcm9wVHlwZXMuZnVuYyxcbiAgb25FbnRlckZyYW1lOiBwcm9wVHlwZXMuZnVuYyxcbiAgb25TZWdtZW50U3RhcnQ6IHByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxudmFyIG5vT3AgPSBmdW5jdGlvbiBub09wKCkge307XG5cbnZhciBtYWtlTG90dGllUGxheWVyID0gZnVuY3Rpb24gbWFrZUxvdHRpZVBsYXllcihfcmVmKSB7XG4gIHZhciBsb2FkQW5pbWF0aW9uID0gX3JlZi5sb2FkQW5pbWF0aW9uO1xuICB2YXIgTG90dGllID0gbWVtbyhmb3J3YXJkUmVmKGZ1bmN0aW9uIChwYXJhbXMsIGZvcndhcmRlZFJlZikge1xuICAgIHZhciBfcGFyYW1zJGFuaW1hdGlvbkRhdGEgPSBwYXJhbXMuYW5pbWF0aW9uRGF0YSxcbiAgICAgICAgYW5pbWF0aW9uRGF0YSA9IF9wYXJhbXMkYW5pbWF0aW9uRGF0YSA9PT0gdm9pZCAwID8gbnVsbCA6IF9wYXJhbXMkYW5pbWF0aW9uRGF0YSxcbiAgICAgICAgX3BhcmFtcyRwYXRoID0gcGFyYW1zLnBhdGgsXG4gICAgICAgIHBhdGggPSBfcGFyYW1zJHBhdGggPT09IHZvaWQgMCA/IG51bGwgOiBfcGFyYW1zJHBhdGgsXG4gICAgICAgIF9wYXJhbXMkcGxheSA9IHBhcmFtcy5wbGF5LFxuICAgICAgICBwbGF5ID0gX3BhcmFtcyRwbGF5ID09PSB2b2lkIDAgPyBudWxsIDogX3BhcmFtcyRwbGF5LFxuICAgICAgICBfcGFyYW1zJHNwZWVkID0gcGFyYW1zLnNwZWVkLFxuICAgICAgICBzcGVlZCA9IF9wYXJhbXMkc3BlZWQgPT09IHZvaWQgMCA/IDEgOiBfcGFyYW1zJHNwZWVkLFxuICAgICAgICBfcGFyYW1zJGRpcmVjdGlvbiA9IHBhcmFtcy5kaXJlY3Rpb24sXG4gICAgICAgIGRpcmVjdGlvbiA9IF9wYXJhbXMkZGlyZWN0aW9uID09PSB2b2lkIDAgPyAxIDogX3BhcmFtcyRkaXJlY3Rpb24sXG4gICAgICAgIF9wYXJhbXMkc2VnbWVudHMgPSBwYXJhbXMuc2VnbWVudHMsXG4gICAgICAgIHNlZ21lbnRzSW4gPSBfcGFyYW1zJHNlZ21lbnRzID09PSB2b2lkIDAgPyBudWxsIDogX3BhcmFtcyRzZWdtZW50cyxcbiAgICAgICAgX3BhcmFtcyRnb1RvID0gcGFyYW1zLmdvVG8sXG4gICAgICAgIGdvVG8gPSBfcGFyYW1zJGdvVG8gPT09IHZvaWQgMCA/IG51bGwgOiBfcGFyYW1zJGdvVG8sXG4gICAgICAgIF9wYXJhbXMkdXNlU3ViZnJhbWVzID0gcGFyYW1zLnVzZVN1YmZyYW1lcyxcbiAgICAgICAgdXNlU3ViZnJhbWVzID0gX3BhcmFtcyR1c2VTdWJmcmFtZXMgPT09IHZvaWQgMCA/IHRydWUgOiBfcGFyYW1zJHVzZVN1YmZyYW1lcyxcbiAgICAgICAgX3BhcmFtcyRyZW5kZXJlciA9IHBhcmFtcy5yZW5kZXJlcixcbiAgICAgICAgcmVuZGVyZXIgPSBfcGFyYW1zJHJlbmRlcmVyID09PSB2b2lkIDAgPyAnc3ZnJyA6IF9wYXJhbXMkcmVuZGVyZXIsXG4gICAgICAgIF9wYXJhbXMkbG9vcCA9IHBhcmFtcy5sb29wLFxuICAgICAgICBsb29wID0gX3BhcmFtcyRsb29wID09PSB2b2lkIDAgPyB0cnVlIDogX3BhcmFtcyRsb29wLFxuICAgICAgICBfcGFyYW1zJHJlbmRlcmVyU2V0dGkgPSBwYXJhbXMucmVuZGVyZXJTZXR0aW5ncyxcbiAgICAgICAgcmVuZGVyZXJTZXR0aW5nc0luID0gX3BhcmFtcyRyZW5kZXJlclNldHRpID09PSB2b2lkIDAgPyBlbXB0eU9iamVjdCA6IF9wYXJhbXMkcmVuZGVyZXJTZXR0aSxcbiAgICAgICAgX3BhcmFtcyRhdWRpb0ZhY3RvcnkgPSBwYXJhbXMuYXVkaW9GYWN0b3J5LFxuICAgICAgICBhdWRpb0ZhY3RvcnkgPSBfcGFyYW1zJGF1ZGlvRmFjdG9yeSA9PT0gdm9pZCAwID8gbnVsbCA6IF9wYXJhbXMkYXVkaW9GYWN0b3J5LFxuICAgICAgICBfcGFyYW1zJG9uTG9hZCA9IHBhcmFtcy5vbkxvYWQsXG4gICAgICAgIG9uTG9hZCA9IF9wYXJhbXMkb25Mb2FkID09PSB2b2lkIDAgPyBub09wIDogX3BhcmFtcyRvbkxvYWQsXG4gICAgICAgIF9wYXJhbXMkb25Db21wbGV0ZSA9IHBhcmFtcy5vbkNvbXBsZXRlLFxuICAgICAgICBvbkNvbXBsZXRlID0gX3BhcmFtcyRvbkNvbXBsZXRlID09PSB2b2lkIDAgPyBub09wIDogX3BhcmFtcyRvbkNvbXBsZXRlLFxuICAgICAgICBfcGFyYW1zJG9uTG9vcENvbXBsZXQgPSBwYXJhbXMub25Mb29wQ29tcGxldGUsXG4gICAgICAgIG9uTG9vcENvbXBsZXRlID0gX3BhcmFtcyRvbkxvb3BDb21wbGV0ID09PSB2b2lkIDAgPyBub09wIDogX3BhcmFtcyRvbkxvb3BDb21wbGV0LFxuICAgICAgICBfcGFyYW1zJG9uRW50ZXJGcmFtZSA9IHBhcmFtcy5vbkVudGVyRnJhbWUsXG4gICAgICAgIG9uRW50ZXJGcmFtZSA9IF9wYXJhbXMkb25FbnRlckZyYW1lID09PSB2b2lkIDAgPyBub09wIDogX3BhcmFtcyRvbkVudGVyRnJhbWUsXG4gICAgICAgIF9wYXJhbXMkb25TZWdtZW50U3RhciA9IHBhcmFtcy5vblNlZ21lbnRTdGFydCxcbiAgICAgICAgb25TZWdtZW50U3RhcnQgPSBfcGFyYW1zJG9uU2VnbWVudFN0YXIgPT09IHZvaWQgMCA/IG5vT3AgOiBfcGFyYW1zJG9uU2VnbWVudFN0YXIsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocGFyYW1zLCBbXCJhbmltYXRpb25EYXRhXCIsIFwicGF0aFwiLCBcInBsYXlcIiwgXCJzcGVlZFwiLCBcImRpcmVjdGlvblwiLCBcInNlZ21lbnRzXCIsIFwiZ29Ub1wiLCBcInVzZVN1YmZyYW1lc1wiLCBcInJlbmRlcmVyXCIsIFwibG9vcFwiLCBcInJlbmRlcmVyU2V0dGluZ3NcIiwgXCJhdWRpb0ZhY3RvcnlcIiwgXCJvbkxvYWRcIiwgXCJvbkNvbXBsZXRlXCIsIFwib25Mb29wQ29tcGxldGVcIiwgXCJvbkVudGVyRnJhbWVcIiwgXCJvblNlZ21lbnRTdGFydFwiXSk7XG5cbiAgICB2YXIgYW5pbUVsZW1lbnRSZWYgPSB1c2VSZWYoKTtcbiAgICB2YXIgYW5pbVJlZiA9IHVzZVJlZigpO1xuXG4gICAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKGZhbHNlKSxcbiAgICAgICAgcmVhZHkgPSBfdXNlU3RhdGVbMF0sXG4gICAgICAgIHNldFJlYWR5ID0gX3VzZVN0YXRlWzFdO1xuXG4gICAgdmFyIF91c2VTdGF0ZTIgPSB1c2VTdGF0ZShzZWdtZW50c0luKSxcbiAgICAgICAgc2VnbWVudHMgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgICBzZXRTZWdtZW50cyA9IF91c2VTdGF0ZTJbMV07XG5cbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFlcXVhbChzZWdtZW50cywgc2VnbWVudHNJbikpIHNldFNlZ21lbnRzKHNlZ21lbnRzSW4pO1xuICAgIH0sIFtzZWdtZW50c0luLCBzZWdtZW50c10pO1xuXG4gICAgdmFyIF91c2VTdGF0ZTMgPSB1c2VTdGF0ZShyZW5kZXJlclNldHRpbmdzSW4pLFxuICAgICAgICByZW5kZXJlclNldHRpbmdzID0gX3VzZVN0YXRlM1swXSxcbiAgICAgICAgc2V0UmVuZGVyZXJTZXR0aW5ncyA9IF91c2VTdGF0ZTNbMV07XG5cbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFlcXVhbChyZW5kZXJlclNldHRpbmdzLCByZW5kZXJlclNldHRpbmdzSW4pKSBzZXRSZW5kZXJlclNldHRpbmdzKHJlbmRlcmVyU2V0dGluZ3NJbik7XG4gICAgfSwgW3JlbmRlcmVyU2V0dGluZ3NJbiwgcmVuZGVyZXJTZXR0aW5nc10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYW5pbVJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgb25Db21wbGV0ZSk7XG4gICAgICB9O1xuICAgIH0sIFtvbkNvbXBsZXRlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhbmltUmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9vcENvbXBsZXRlJywgb25Mb29wQ29tcGxldGUpO1xuICAgICAgfTtcbiAgICB9LCBbb25Mb29wQ29tcGxldGVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFuaW1SZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlckZyYW1lJywgb25FbnRlckZyYW1lKTtcbiAgICAgIH07XG4gICAgfSwgW29uRW50ZXJGcmFtZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYW5pbVJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZ21lbnRTdGFydCcsIG9uU2VnbWVudFN0YXJ0KTtcbiAgICAgIH07XG4gICAgfSwgW29uU2VnbWVudFN0YXJ0XSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhbmltUmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTG9hZGVkJywgb25Mb2FkKTtcbiAgICAgIH07XG4gICAgfSwgW29uTG9hZF0pO1xuICAgIHZhciBzZXRMb3R0aWVSZWZzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5ld1JlZikge1xuICAgICAgYW5pbVJlZi5jdXJyZW50ID0gbmV3UmVmO1xuICAgICAgaWYgKGZvcndhcmRlZFJlZikgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBuZXdSZWY7XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBwYXJzZUFuaW1hdGlvbkRhdGEoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25EYXRhID09IG51bGwgfHwgdHlwZW9mIGFuaW1hdGlvbkRhdGEgIT09ICdvYmplY3QnKSByZXR1cm4gYW5pbWF0aW9uRGF0YTtcblxuICAgICAgICBpZiAodHlwZW9mIGFuaW1hdGlvbkRhdGFbXCJkZWZhdWx0XCJdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJldHVybiBjbG9uZShhbmltYXRpb25EYXRhW1wiZGVmYXVsdFwiXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmUoYW5pbWF0aW9uRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb3R0aWUgPSBsb2FkQW5pbWF0aW9uKHtcbiAgICAgICAgYW5pbWF0aW9uRGF0YTogcGFyc2VBbmltYXRpb25EYXRhKCksXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGNvbnRhaW5lcjogYW5pbUVsZW1lbnRSZWYuY3VycmVudCxcbiAgICAgICAgcmVuZGVyZXI6IHJlbmRlcmVyLFxuICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgICByZW5kZXJlclNldHRpbmdzOiByZW5kZXJlclNldHRpbmdzLFxuICAgICAgICBhdWRpb0ZhY3Rvcnk6IGF1ZGlvRmFjdG9yeVxuICAgICAgfSk7XG4gICAgICBzZXRMb3R0aWVSZWZzKGxvdHRpZSk7XG5cbiAgICAgIHZhciBvbkRvbUxvYWRlZCA9IGZ1bmN0aW9uIG9uRG9tTG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gc2V0UmVhZHkodHJ1ZSk7XG4gICAgICB9O1xuXG4gICAgICBhbmltUmVmLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTG9hZGVkJywgb25Eb21Mb2FkZWQpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYW5pbVJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUxvYWRlZCcsIG9uRG9tTG9hZGVkKTtcbiAgICAgICAgc2V0UmVhZHkoZmFsc2UpO1xuICAgICAgICBhbmltUmVmLmN1cnJlbnQuZGVzdHJveSgpO1xuICAgICAgICBzZXRMb3R0aWVSZWZzKHVuZGVmaW5lZCk7XG4gICAgICB9O1xuICAgIH0sIFtsb29wLCByZW5kZXJlciwgcmVuZGVyZXJTZXR0aW5ncywgYW5pbWF0aW9uRGF0YSwgcGF0aCwgYXVkaW9GYWN0b3J5LCBzZXRMb3R0aWVSZWZzXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFuaW1SZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdET01Mb2FkZWQnLCBvbkxvYWQpO1xuICAgIH0sIFtvbkxvYWRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgYW5pbVJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgb25Db21wbGV0ZSk7XG4gICAgfSwgW29uQ29tcGxldGVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgYW5pbVJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvb3BDb21wbGV0ZScsIG9uTG9vcENvbXBsZXRlKTtcbiAgICB9LCBbb25Mb29wQ29tcGxldGVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgYW5pbVJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVyRnJhbWUnLCBvbkVudGVyRnJhbWUpO1xuICAgIH0sIFtvbkVudGVyRnJhbWVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgYW5pbVJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlZ21lbnRTdGFydCcsIG9uU2VnbWVudFN0YXJ0KTtcbiAgICB9LCBbb25TZWdtZW50U3RhcnRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFyZWFkeSkgcmV0dXJuO1xuICAgICAgYW5pbVJlZi5jdXJyZW50Lmxvb3AgPSBsb29wO1xuICAgIH0sIFtyZWFkeSwgbG9vcF0pO1xuICAgIHZhciB3YXNQbGF5aW5nU2VnbWVudHNSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXJlYWR5KSByZXR1cm47XG5cbiAgICAgIGZ1bmN0aW9uIHBsYXlSZXZlcnNlKGxhc3RGcmFtZSkge1xuICAgICAgICBhbmltUmVmLmN1cnJlbnQuZ29Ub0FuZFBsYXkobGFzdEZyYW1lLCB0cnVlKTtcbiAgICAgICAgYW5pbVJlZi5jdXJyZW50LnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAocGxheSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgZm9yY2UgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICAgIGFuaW1SZWYuY3VycmVudC5wbGF5U2VnbWVudHMoc2VnbWVudHMsIGZvcmNlKTtcbiAgICAgICAgICB3YXNQbGF5aW5nU2VnbWVudHNSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgdmFyIGxhc3RGcmFtZSA9IHNlZ21lbnRzWzFdO1xuICAgICAgICAgICAgcGxheVJldmVyc2UobGFzdEZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHdhc1BsYXlpbmdTZWdtZW50c1JlZi5jdXJyZW50KSBhbmltUmVmLmN1cnJlbnQucmVzZXRTZWdtZW50cyhmb3JjZSk7XG4gICAgICAgICAgd2FzUGxheWluZ1NlZ21lbnRzUmVmLmN1cnJlbnQgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgX2xhc3RGcmFtZSA9IGFuaW1SZWYuY3VycmVudC5nZXREdXJhdGlvbih0cnVlKTtcblxuICAgICAgICAgICAgcGxheVJldmVyc2UoX2xhc3RGcmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuaW1SZWYuY3VycmVudC5wbGF5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBsYXkgPT09IGZhbHNlKSB7XG4gICAgICAgIGFuaW1SZWYuY3VycmVudC5wYXVzZSgpO1xuICAgICAgfVxuICAgIH0sIFtwbGF5LCBzZWdtZW50cywgcmVhZHksIGRpcmVjdGlvbl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXJlYWR5KSByZXR1cm47XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKHNwZWVkKSkgcmV0dXJuO1xuICAgICAgYW5pbVJlZi5jdXJyZW50LnNldFNwZWVkKHNwZWVkKTtcbiAgICB9LCBbc3BlZWQsIHJlYWR5XSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghcmVhZHkpIHJldHVybjtcbiAgICAgIGFuaW1SZWYuY3VycmVudC5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICB9LCBbZGlyZWN0aW9uLCByZWFkeV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXJlYWR5KSByZXR1cm47XG4gICAgICBpZiAoZ29UbyA9PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgaXNGcmFtZSA9IHRydWU7XG4gICAgICBpZiAocGxheSkgYW5pbVJlZi5jdXJyZW50LmdvVG9BbmRQbGF5KGdvVG8sIGlzRnJhbWUpO2Vsc2UgYW5pbVJlZi5jdXJyZW50LmdvVG9BbmRTdG9wKGdvVG8sIGlzRnJhbWUpO1xuICAgIH0sIFtnb1RvLCBwbGF5LCByZWFkeV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYW5pbVJlZi5jdXJyZW50LnNldFN1YmZyYW1lKSBhbmltUmVmLmN1cnJlbnQuc2V0U3ViZnJhbWUodXNlU3ViZnJhbWVzKTtcbiAgICB9LCBbdXNlU3ViZnJhbWVzXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgcmVmOiBhbmltRWxlbWVudFJlZlxuICAgIH0pKTtcbiAgfSkpO1xuICBMb3R0aWUucHJvcFR5cGVzID0gcHJvcFR5cGVzJDE7XG4gIHJldHVybiBMb3R0aWU7XG59O1xuXG52YXIgTG90dGllUGxheWVyID0gbWFrZUxvdHRpZVBsYXllcihsb3R0aWUpO1xuXG5leHBvcnQgZGVmYXVsdCBMb3R0aWVQbGF5ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb3R0aWVQbGF5ZXIubW9kZXJuLmpzLm1hcFxuIl0sIm5hbWVzIjpbImxvdHRpZSIsIlJlYWN0IiwibWVtbyIsImZvcndhcmRSZWYiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiZXF1YWwiLCJjbG9uZSIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJrZXlzIiwiaW5kZXhPZiIsImNyZWF0ZUNvbW1vbmpzTW9kdWxlIiwiZm4iLCJtb2R1bGUiLCJleHBvcnRzIiwiYiIsIlN5bWJvbCIsImZvciIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImsiLCJsIiwibSIsIm4iLCJwIiwicSIsInIiLCJ0IiwidiIsInciLCJ4IiwieSIsInoiLCJhIiwidSIsIiQkdHlwZW9mIiwidHlwZSIsIkEiLCJBc3luY01vZGUiLCJDb25jdXJyZW50TW9kZSIsIkNvbnRleHRDb25zdW1lciIsIkNvbnRleHRQcm92aWRlciIsIkVsZW1lbnQiLCJGb3J3YXJkUmVmIiwiRnJhZ21lbnQiLCJMYXp5IiwiTWVtbyIsIlBvcnRhbCIsIlByb2ZpbGVyIiwiU3RyaWN0TW9kZSIsIlN1c3BlbnNlIiwiaXNBc3luY01vZGUiLCJpc0NvbmN1cnJlbnRNb2RlIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJpc0NvbnRleHRQcm92aWRlciIsImlzRWxlbWVudCIsImlzRm9yd2FyZFJlZiIsImlzRnJhZ21lbnQiLCJpc0xhenkiLCJpc01lbW8iLCJpc1BvcnRhbCIsImlzUHJvZmlsZXIiLCJpc1N0cmljdE1vZGUiLCJpc1N1c3BlbnNlIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwidHlwZU9mIiwicmVhY3RJc19wcm9kdWN0aW9uX21pbiIsInJlYWN0SXNfZGV2ZWxvcG1lbnQiLCJwcm9jZXNzIiwiaGFzU3ltYm9sIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfQVNZTkNfTU9ERV9UWVBFIiwiUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX0JMT0NLX1RZUEUiLCJSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIiwiUkVBQ1RfUkVTUE9OREVSX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwib2JqZWN0IiwiJCR0eXBlb2ZUeXBlIiwidW5kZWZpbmVkIiwiaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUiLCJjb25zb2xlIiwicmVhY3RJcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidmFsIiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwidGVzdDEiLCJTdHJpbmciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJtYXAiLCJqb2luIiwidGVzdDMiLCJzcGxpdCIsImZvckVhY2giLCJsZXR0ZXIiLCJlcnIiLCJvYmplY3RBc3NpZ24iLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0IiwiUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSIsImhhcyIsIkZ1bmN0aW9uIiwiYmluZCIsInByaW50V2FybmluZyIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0JDEiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJoYXMkMSIsInRleHQiLCJtZXNzYWdlIiwiZXJyb3IiLCJFcnJvciIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJuYW1lIiwiZXgiLCJzdGFjayIsInJlc2V0V2FybmluZ0NhY2hlIiwiY2hlY2tQcm9wVHlwZXNfMSIsInByaW50V2FybmluZyQxIiwiZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCIsImZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzIiwiaXNWYWxpZEVsZW1lbnQiLCJ0aHJvd09uRGlyZWN0QWNjZXNzIiwiSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsIkFOT05ZTU9VUyIsIlJlYWN0UHJvcFR5cGVzIiwiYXJyYXkiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsImJpZ2ludCIsImJvb2wiLCJmdW5jIiwibnVtYmVyIiwic3RyaW5nIiwic3ltYm9sIiwiYW55IiwiY3JlYXRlQW55VHlwZUNoZWNrZXIiLCJhcnJheU9mIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiZWxlbWVudCIsImNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlciIsImVsZW1lbnRUeXBlIiwiY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlciIsImluc3RhbmNlT2YiLCJjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyIiwibm9kZSIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwic2hhcGUiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiZXhhY3QiLCJjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyIiwiaXMiLCJQcm9wVHlwZUVycm9yIiwiZGF0YSIsImNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyIiwidmFsaWRhdGUiLCJtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSIsIm1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IiwiY2hlY2tUeXBlIiwiaXNSZXF1aXJlZCIsInByb3BzIiwicHJvcE5hbWUiLCJwcm9wRnVsbE5hbWUiLCJzZWNyZXQiLCJjYWNoZUtleSIsImNoYWluZWRDaGVja1R5cGUiLCJleHBlY3RlZFR5cGUiLCJwcm9wVmFsdWUiLCJwcm9wVHlwZSIsImdldFByb3BUeXBlIiwicHJlY2lzZVR5cGUiLCJnZXRQcmVjaXNlVHlwZSIsInR5cGVDaGVja2VyIiwiQXJyYXkiLCJpc0FycmF5IiwiZXhwZWN0ZWRDbGFzcyIsImV4cGVjdGVkQ2xhc3NOYW1lIiwiYWN0dWFsQ2xhc3NOYW1lIiwiZ2V0Q2xhc3NOYW1lIiwiZXhwZWN0ZWRWYWx1ZXMiLCJ2YWx1ZXNTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwicmVwbGFjZXIiLCJ2YWx1ZSIsImFycmF5T2ZUeXBlQ2hlY2tlcnMiLCJjaGVja2VyIiwiZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nIiwiZXhwZWN0ZWRUeXBlcyIsImNoZWNrZXJSZXN1bHQiLCJwdXNoIiwiZXhwZWN0ZWRUeXBlc01lc3NhZ2UiLCJpc05vZGUiLCJpbnZhbGlkVmFsaWRhdG9yRXJyb3IiLCJzaGFwZVR5cGVzIiwiYWxsS2V5cyIsImV2ZXJ5Iiwic3RlcCIsImVudHJpZXMiLCJuZXh0IiwiZG9uZSIsImVudHJ5IiwiaXNTeW1ib2wiLCJSZWdFeHAiLCJEYXRlIiwiY29uc3RydWN0b3IiLCJQcm9wVHlwZXMiLCJlbXB0eUZ1bmN0aW9uIiwiZW1wdHlGdW5jdGlvbldpdGhSZXNldCIsImZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcyIsInNoaW0iLCJnZXRTaGltIiwicHJvcFR5cGVzIiwiUmVhY3RJcyIsInByb3BUeXBlcyQxIiwiYW5pbWF0aW9uRGF0YSIsInBhdGgiLCJwbGF5IiwiZ29UbyIsInNwZWVkIiwiZGlyZWN0aW9uIiwibG9vcCIsInVzZVN1YmZyYW1lcyIsInNlZ21lbnRzIiwicmVuZGVyZXJTZXR0aW5ncyIsInJlbmRlcmVyIiwiYXVkaW9GYWN0b3J5Iiwib25Db21wbGV0ZSIsIm9uTG9vcENvbXBsZXRlIiwib25FbnRlckZyYW1lIiwib25TZWdtZW50U3RhcnQiLCJlbXB0eU9iamVjdCIsIm5vT3AiLCJtYWtlTG90dGllUGxheWVyIiwiX3JlZiIsImxvYWRBbmltYXRpb24iLCJMb3R0aWUiLCJwYXJhbXMiLCJmb3J3YXJkZWRSZWYiLCJfcGFyYW1zJGFuaW1hdGlvbkRhdGEiLCJfcGFyYW1zJHBhdGgiLCJfcGFyYW1zJHBsYXkiLCJfcGFyYW1zJHNwZWVkIiwiX3BhcmFtcyRkaXJlY3Rpb24iLCJfcGFyYW1zJHNlZ21lbnRzIiwic2VnbWVudHNJbiIsIl9wYXJhbXMkZ29UbyIsIl9wYXJhbXMkdXNlU3ViZnJhbWVzIiwiX3BhcmFtcyRyZW5kZXJlciIsIl9wYXJhbXMkbG9vcCIsIl9wYXJhbXMkcmVuZGVyZXJTZXR0aSIsInJlbmRlcmVyU2V0dGluZ3NJbiIsIl9wYXJhbXMkYXVkaW9GYWN0b3J5IiwiX3BhcmFtcyRvbkxvYWQiLCJvbkxvYWQiLCJfcGFyYW1zJG9uQ29tcGxldGUiLCJfcGFyYW1zJG9uTG9vcENvbXBsZXQiLCJfcGFyYW1zJG9uRW50ZXJGcmFtZSIsIl9wYXJhbXMkb25TZWdtZW50U3RhciIsImFuaW1FbGVtZW50UmVmIiwiYW5pbVJlZiIsIl91c2VTdGF0ZSIsInJlYWR5Iiwic2V0UmVhZHkiLCJfdXNlU3RhdGUyIiwic2V0U2VnbWVudHMiLCJfdXNlU3RhdGUzIiwic2V0UmVuZGVyZXJTZXR0aW5ncyIsImN1cnJlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2V0TG90dGllUmVmcyIsIm5ld1JlZiIsInBhcnNlQW5pbWF0aW9uRGF0YSIsImNvbnRhaW5lciIsImF1dG9wbGF5Iiwib25Eb21Mb2FkZWQiLCJhZGRFdmVudExpc3RlbmVyIiwiZGVzdHJveSIsIndhc1BsYXlpbmdTZWdtZW50c1JlZiIsInBsYXlSZXZlcnNlIiwibGFzdEZyYW1lIiwiZ29Ub0FuZFBsYXkiLCJzZXREaXJlY3Rpb24iLCJmb3JjZSIsInBsYXlTZWdtZW50cyIsInJlc2V0U2VnbWVudHMiLCJfbGFzdEZyYW1lIiwiZ2V0RHVyYXRpb24iLCJwYXVzZSIsIk51bWJlciIsImlzTmFOIiwic2V0U3BlZWQiLCJpc0ZyYW1lIiwiZ29Ub0FuZFN0b3AiLCJzZXRTdWJmcmFtZSIsImNyZWF0ZUVsZW1lbnQiLCJyZWYiLCJMb3R0aWVQbGF5ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-lottie-player/dist/LottiePlayer.modern.js\n");

/***/ })

};
;